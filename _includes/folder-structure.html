<!-- ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼æ§‹é€ ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆWindows File Explorerã®ã‚ˆã†ãªãƒ„ãƒªãƒ¼è¡¨ç¤ºï¼‰ -->
<nav class="folder-structure">
  <h3>ğŸ“ ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼æ§‹é€ </h3>
  <div id="folder-tree-container" class="folder-tree"></div>
</nav>

<script>
(function() {
  // ã‚µã‚¤ãƒˆå†…ã®ã™ã¹ã¦ã®ãƒšãƒ¼ã‚¸ã¨ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰éšå±¤æ§‹é€ ã‚’æ§‹ç¯‰
  // JSON å½¢å¼ã§å®‰å…¨ã«æ—¥æœ¬èªãƒ‡ãƒ¼ã‚¿ã‚’æ¸¡ã™
  const pagesData = [
    {% for item in site.pages -%}
    {
      path: {{ item.path | jsonify }},
      dir: {{ item.dir | jsonify }},
      name: {{ item.name | jsonify }},
      url: {{ item.url | relative_url | jsonify }},
      type: "page"
    },
    {% endfor -%}
    {% for file in site.static_files -%}
    {
      path: {{ file.path | jsonify }},
      dir: {{ file.dir | jsonify }},
      name: {{ file.name | jsonify }},
      url: {{ file.path | relative_url | jsonify }},
      type: "file"
    },
    {% endfor -%}
  ];

  // URLãƒ‡ã‚³ãƒ¼ãƒ‰é–¢æ•°ï¼ˆå®‰å…¨ãªãƒ‡ã‚³ãƒ¼ãƒ‰ï¼‰
  function safeDecodeURIComponent(str) {
    try {
      return decodeURIComponent(str);
    } catch (e) {
      // ãƒ‡ã‚³ãƒ¼ãƒ‰ã«å¤±æ•—ã—ãŸå ´åˆã¯å…ƒã®æ–‡å­—åˆ—ã‚’è¿”ã™
      return str;
    }
  }

  // ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼ãƒ„ãƒªãƒ¼ã‚’æ§‹ç¯‰
  const folderTree = {};

  pagesData.forEach(item => {
    if (!item.dir) return;
    
    // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰
    const decodedDir = safeDecodeURIComponent(item.dir);
    const parts = decodedDir.split('/').filter(p => p && p !== '.');
    let current = folderTree;
    
    parts.forEach((part, idx) => {
      // ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼åã‚‚ãƒ‡ã‚³ãƒ¼ãƒ‰
      const decodedPart = safeDecodeURIComponent(part);
      if (!current[decodedPart]) {
        current[decodedPart] = { _files: [], _folders: {} };
      }
      if (idx === parts.length - 1) {
        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã“ã®ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼ã«è¿½åŠ 
        if (!current[decodedPart]._files) current[decodedPart]._files = [];
        current[decodedPart]._files.push(item);
      }
      current = current[decodedPart]._folders || (current[decodedPart]._folders = {});
    });
  });

  // ãƒ„ãƒªãƒ¼HTMLã‚’ç”Ÿæˆ
  function generateTreeHTML(tree, basePath = '/') {
    const folderNames = Object.keys(tree)
      .filter(key => key !== '_files' && key !== '_folders')
      .sort();
    
    if (folderNames.length === 0) return '';

    let html = '<ul>';
    
    folderNames.forEach(folderName => {
      const folderData = tree[folderName];
      // URLã«ã¯ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ‘ã‚¹ã‚’ä½¿ç”¨
      const encodedFolderName = encodeURIComponent(folderName);
      const folderPath = basePath + encodedFolderName + '/';
      const hasChildren = Object.keys(folderData._folders || {}).length > 0 || 
                          (folderData._files && folderData._files.length > 0);
      
      if (hasChildren) {
        html += `<li class="folder-item">
          <details>
            <summary class="folder-toggle">
              <span class="folder-icon">ğŸ“</span>
              <span class="folder-name">${escapeHtml(folderName)}</span>
            </summary>
            <ul class="nested">`;
        
        // ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼ã‚’è¡¨ç¤º
        const subFolders = folderData._folders || {};
        const subFolderNames = Object.keys(subFolders).sort();
        
        subFolderNames.forEach(subFolderName => {
          const encodedSubFolderName = encodeURIComponent(subFolderName);
          const subFolderPath = folderPath + encodedSubFolderName + '/';
          const subFolderData = subFolders[subFolderName];
          const hasSubChildren = Object.keys(subFolderData._folders || {}).length > 0 || 
                                 (subFolderData._files && subFolderData._files.length > 0);
          
          if (hasSubChildren) {
            html += `<li class="folder-item">
              <details>
                <summary class="folder-toggle">
                  <span class="folder-icon">ğŸ“</span>
                  <span class="folder-name">${escapeHtml(subFolderName)}</span>
                </summary>
                ${generateFolderContents(subFolderData, subFolderPath)}
              </details>
            </li>`;
          } else {
            html += `<li class="folder-item">
              <a href="${escapeHtml(subFolderPath)}" class="folder-link">
                <span class="folder-icon">ğŸ“</span>
                <span class="folder-name">${escapeHtml(subFolderName)}</span>
              </a>
            </li>`;
          }
        });
        
        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¡¨ç¤º
        if (folderData._files && folderData._files.length > 0) {
          folderData._files.forEach(file => {
            const fileName = file.name;
            const fileExt = fileName.split('.').pop().toLowerCase();
            const fileIcon = getFileIcon(fileExt);
            html += `<li class="file-item">
              <a href="${escapeHtml(file.url)}" class="file-link">
                <span class="file-icon">${fileIcon}</span>
                <span class="file-name">${escapeHtml(fileName)}</span>
              </a>
            </li>`;
          });
        }
        
        html += `</ul>
            </details>
          </li>`;
      }
    });
    
    html += '</ul>';
    return html;
  }

  function generateFolderContents(folderData, basePath) {
    const subFolders = folderData._folders || {};
    const subFolderNames = Object.keys(subFolders).sort();
    
    let html = '<ul class="nested">';
    
    subFolderNames.forEach(subFolderName => {
      const encodedSubFolderName = encodeURIComponent(subFolderName);
      const subFolderPath = basePath + encodedSubFolderName + '/';
      const subFolderData = subFolders[subFolderName];
      const hasSubChildren = Object.keys(subFolderData._folders || {}).length > 0 || 
                             (subFolderData._files && subFolderData._files.length > 0);
      
      if (hasSubChildren) {
        html += `<li class="folder-item">
          <details>
            <summary class="folder-toggle">
              <span class="folder-icon">ğŸ“</span>
              <span class="folder-name">${escapeHtml(subFolderName)}</span>
            </summary>
            ${generateFolderContents(subFolderData, subFolderPath)}
          </details>
        </li>`;
      } else {
        html += `<li class="folder-item">
          <a href="${escapeHtml(subFolderPath)}" class="folder-link">
            <span class="folder-icon">ğŸ“</span>
            <span class="folder-name">${escapeHtml(subFolderName)}</span>
          </a>
        </li>`;
      }
    });
    
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¡¨ç¤º
    if (folderData._files && folderData._files.length > 0) {
      folderData._files.forEach(file => {
        const fileName = file.name;
        const fileExt = fileName.split('.').pop().toLowerCase();
        const fileIcon = getFileIcon(fileExt);
        html += `<li class="file-item">
          <a href="${escapeHtml(file.url)}" class="file-link">
            <span class="file-icon">${fileIcon}</span>
            <span class="file-name">${escapeHtml(fileName)}</span>
          </a>
        </li>`;
      });
    }
    
    html += '</ul>';
    return html;
  }

  function getFileIcon(ext) {
    const iconMap = {
      'md': 'ğŸ“„',
      'html': 'ğŸŒ',
      'pdf': 'ğŸ“•',
      'jpg': 'ğŸ–¼ï¸',
      'jpeg': 'ğŸ–¼ï¸',
      'png': 'ğŸ–¼ï¸',
      'gif': 'ğŸ¬',
      'zip': 'ğŸ“¦',
      'json': 'âš™ï¸',
      'yml': 'âš™ï¸',
      'yaml': 'âš™ï¸',
      'css': 'ğŸ¨',
      'js': 'ğŸ“œ',
      'txt': 'ğŸ“'
    };
    return iconMap[ext] || 'ğŸ“„';
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // ãƒ„ãƒªãƒ¼ã‚’è¡¨ç¤º
  const container = document.getElementById('folder-tree-container');
  
  // ãƒ‡ãƒãƒƒã‚°: æœ€åˆã®æ•°é …ç›®ã‚’ç¢ºèª
  if (pagesData.length > 0) {
    console.log('ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼æ§‹é€ ãƒ‡ãƒ¼ã‚¿ã‚µãƒ³ãƒ—ãƒ«:', pagesData.slice(0, 3));
  }
  
  // ãƒ›ãƒ¼ãƒ ãƒªãƒ³ã‚¯ã‚’å…ˆã«è¿½åŠ 
  let html = '<ul class="root-tree">';
  html += '<li class="home-item"><a href="{{ "/" | relative_url }}" class="home-link">ğŸ  ãƒ›ãƒ¼ãƒ </a></li>';
  
  // ãƒ«ãƒ¼ãƒˆç›´ä¸‹ã®ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼ã‚’è¡¨ç¤º
  const rootFolders = Object.keys(folderTree)
    .filter(key => key !== '_files' && key !== '_folders')
    .sort();
  
  // ãƒ‡ãƒãƒƒã‚°: ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€ãƒ¼ã®ç¢ºèª
  console.log('ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€ãƒ¼ä¸€è¦§:', rootFolders);
  
  html += '<ul class="nested">';
  
  rootFolders.forEach(folderName => {
    const folderData = folderTree[folderName];
    const encodedFolderName = encodeURIComponent(folderName);
    const folderPath = '/' + encodedFolderName + '/';
    const hasChildren = Object.keys(folderData._folders || {}).length > 0 || 
                        (folderData._files && folderData._files.length > 0);
    
    if (hasChildren) {
      html += `<li class="folder-item">
        <details>
          <summary class="folder-toggle">
            <span class="folder-icon">ğŸ“</span>
            <span class="folder-name">${escapeHtml(folderName)}</span>
          </summary>
          ${generateFolderContents(folderData, folderPath)}
        </details>
      </li>`;
    } else {
      html += `<li class="folder-item">
        <a href="${escapeHtml(folderPath)}" class="folder-link">
          <span class="folder-icon">ğŸ“</span>
          <span class="folder-name">${escapeHtml(folderName)}</span>
        </a>
      </li>`;
    }
  });
  
  html += '</ul></ul>';
  container.innerHTML = html;
})();
</script>

<style>
.folder-structure {
  font-family: 'Segoe UI', 'Meiryo', sans-serif;
  padding: 0;
  background-color: transparent;
  border-radius: 0;
  margin: 0;
}

.folder-structure h3 {
  margin: 0 0 15px 0;
  font-size: 16px;
  color: #333;
}

#folder-tree-container {
  font-size: 13px;
}

.root-tree, .nested {
  list-style: none;
  padding-left: 20px;
  margin: 0;
}

.root-tree {
  padding-left: 0;
}

.home-item a {
  color: #0066cc;
  text-decoration: none;
  display: flex;
  align-items: center;
  padding: 4px 0;
  font-weight: 500;
}

.home-item a:hover {
  text-decoration: underline;
}

.folder-item, .file-item {
  margin: 2px 0;
  list-style: none;
}

details {
  display: block;
}

details > summary {
  cursor: pointer;
  user-select: none;
  padding: 4px 0;
  display: flex;
  align-items: center;
}

details > summary:hover {
  background-color: #f0f0f0;
  border-radius: 2px;
}

.folder-toggle {
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  font-weight: 500;
}

.folder-link, .file-link {
  color: #0066cc;
  text-decoration: none;
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 0;
}

.folder-link:hover, .file-link:hover {
  text-decoration: underline;
}

.folder-icon, .file-icon {
  display: inline-block;
  width: 16px;
  text-align: center;
  flex-shrink: 0;
}

.folder-name, .file-name {
  word-break: break-word;
  word-wrap: break-word;
  overflow-wrap: break-word;
}

/* å±•é–‹çŸ¢å°ã®ã‚¹ã‚¿ã‚¤ãƒ«èª¿æ•´ */
details > summary::-webkit-details-marker {
  margin-right: 6px;
}

@media (prefers-color-scheme: dark) {
  .folder-structure h3 {
    color: #e0e0e0;
  }

  .home-item a, .folder-link, .file-link {
    color: #66b3ff;
  }

  details > summary:hover {
    background-color: #333;
  }
}
</style>

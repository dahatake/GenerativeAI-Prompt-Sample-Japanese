# 要求定義作成

事業のアイディア、議事録、プロジェクトプランなどから、ソフトウェアエンジニアがアプリケーション開発に着手するための入力情報となりえるドキュメントを作成します。

GitHub Copilot AgentへのIssue候補でもあります。

https://docs.github.com/ja/enterprise-cloud@latest/copilot/using-github-copilot/coding-agent/about-assigning-tasks-to-copilot

# 作戦

アプリケーションは何らかの**課題**の解決のためのツールとして価値を発揮します。
そのため、課題の抽出に力点をあてて話を進めていきます。

# ドキュメント作成

ツールは、最近のLLMであれば、どれでもそれなりにドキュメントを作成してくれます。

おすすめツール:
- (最強) Microsoft 365 Copilot Researcher
    - https://blogs.windows.com/japan/2025/04/14/introducing-researcher-and-analyst-in-microsoft-365-copilot/
    - Researcherが使える方は、こちらの利用を強くお勧めします。より詳細なドキュメントの作成をしてくれますし、何よりその理由の説明のドラフトの作成が強力です。

- Microsoft 365 Copilot
    - https://www.microsoft.com/ja-jp/microsoft-365/copilot/copilot-for-work


ドキュメント化することが大事です。
- テキストのファイル: 各Promptの中で**要求定義**など、そのドキュメントが世間一般で通じる名称、つまり、LLMがどんなドキュメントなのかの判断がつきやすいです
- Wordなど: 長文であっても、章ごとに**意味のある塊**としてLLMに伝えやすくなります。また、OneDriveなどに置いておけば、バックアップ、バージョン管理、共同作業などがしやすくなります。Microsoft 365 Copilotの場合は、そのファイルをアップロードあるいはOneDrive上のファイルの参照が容易にできるため、入力ドキュメントの指定としての正確性が増します。
- 一つ一つのPromptの出力文字列が長くなる傾向があります。そのため以下のタイミングで、出力結果をMicrosoft 365のLoopに出力するなどして、別の新規の会話で作業を継続することも検討してください。これは将来のモデルの能力が高まれば改善される可能性もあります。



各ステップでの出力ですが、以下の様に使用すると良いかと思います。

- 通常のCopilotなど

    - チャットを継続してください

- Researcherなど、Deep Research 系
    - チャットは可能な限り1つのチャットの中で処理をしてください。コンテキストが引き継がれて、よりよい出力結果を得られやすいです。
    - それでも通常と比較すると、会話の回数は少なくなります。トークン数が多すぎるためです。4-5回程度の会話で限界かもしれません。
    - チャットの成果物は、Loopに出力して、その後Wordに出力することをお勧めします。そのWordのファイルを次の入力の情報として使ってください

## Step.1 対象事業の選定

これは、アプリケーション開発対象の事業が何か決まっていない場合に使います。
ここではAs-IsとTo-Beを一度に作成します。もし、出力結果が多すぎる場合は、以下の様にステップを分割することをお勧めします😊

リサーチルールがおススメです。

- As-Isだけ作成
- その後 To-Be作成

```text
# 役割
- あなたはMBAを保有している、世界最高峰クラスのビジネス戦略コンサルタントとして振舞ってください。

# 目的
- 私は{企業名}の事業の課題とその解決策について調査しています。
- {企業名}の過去10年間の事業分析を行って、{事業分析レポート構成}に沿った論理的かつ説得力のある詳細なレポートを作成してください。

# ガイドライン
- まず、実施内容の簡潔なチェックリスト（3～7項目）を箇条書きで示してください。それぞれの項目は概念的なもので、実装レベルには踏み込まないでください。

# 事業分析レポート構成

1. **エグゼクティブサマリー**
    - 調査の目的と背景
    - 主な発見と提言の要約
    - 今後のアクションの方向性
2. **内部環境分析**
    - 組織構造とガバナンス
    - 人材・スキルセット
    - オペレーション（生産、物流、品質管理など）
    - 財務状況（収益性、コスト構造、キャッシュフロー）
    - IT・デジタル活用状況
3. **顧客・製品・サービス分析**
    - 顧客セグメントとニーズ
    - 製品・サービスの提供価値（バリュープロポジション）
    - 顧客満足度・NPSなどの指標
    - 売上構成と収益性の高い製品群
4. **業務プロセス分析（As-Is / To-Be）**
    - 現行業務フローの可視化
    - ボトルネックや非効率の特定
    - 改善余地のあるプロセス領域（深く・詳細に）
5. **DX・テクノロジー活用状況**
    - 現在のデジタル化レベル
    - データ活用・分析基盤の整備状況
    - 自動化・AI導入の可能性
6. **改善提言とインパクト評価**
    - 改善施策の提案（短期・中長期）
    - 各施策のROI・KPI試算
    - 実行優先度とロードマップ案

# 出力形式・記載上の注意
- 各フィールドの内容はビジネスコンサルタント視点で論理的に記述し、詳細な説明を心がけてください。必要に応じて追加的なサブポイントは配列やリストで表現して構いません。
```

M365 Copilotを使っている場合は、出力結果を**Pageに編集**で、Loopのファイルとして保存するのが便利です。

## Step.2 ユースケース作成

事業課題から、ユースケースを作成します。

一度に全てを作成しきれない事があります。その場合は、まずは一覧を作成して、その中から、ユースケースの詳細を作成したいものを選定して、先に進みます。

### Step.2.1 ユースケース一覧作成 

Step.1 で作成したLoopのファイルを**作業コンテンツ** (添付ファイル)として追加します。

```text
# 役割
あなたは歴史上最高のSoftware EngineeringのProduct Managerです。

# タスク
- 添付ドキュメントには、ある企業の事業課題とその解決策が含まれています。

- 解決策の実現方法を慎重に検討してください。
- 実現の手段として、ソフトウェアが効果的に利用できるものと、そうでないものがあります。
- ソフトウェアが効果的に利用できるものだけを選択して、それらのユースケースをリストアップして、箇条書きで作成してください。
- それぞれのユースケースには、以下の項目を含めてください。
  - ユースケースID
  - 名称
  - ユースケースの詳細な説明
  - ユースケースとして抽出した詳細な選定の理由
  - 利用できる既存のアプリケーション。もしくは、SaaSサービス。独自に開発しなくても良いもの。
  - 新規に独自に開発した方がメリットが大きい場合には、その具体的かつ説得力のある詳細な理由の説明
  - 新規に独自に開発した方がメリットが大きい場合には、ビジネス上の価値について1-5でランク付け。区分：Low=1–2 / Med=3 / High=4–5
- 必要な情報が不足している場合は、その項目には"N/A"と入力してください。

# ガイドライン
- はじめに行う作業の概要を、3～7項目程度のコンセプチュアルなチェックリストとして簡潔に示してください。
- もし作業を進めるための情報が不足してたら、ユーザーに質問をしてください。
```

```text
独自開発の有効性と、ビジネス価値ランクを中心に分析して、独自開発に取り組むべきユースケースのを、マトリックス化して、ロードマップを作成してください。
```

### Step.2.2 ユースケース作成

ユースケースを1つだけ選択して、そのユースケースの詳細を作成します。
step.2.1でのチャットを継続するのがおススメです。

```text
# タスク
- 対象のユースケース（JBO-UC-001: 電子申請・電子決裁）について、ソフトウェアとして独自に実装するための、できる限り詳細かつ具体的で深い、ユースケースを作成してください。
- 作成するユースケースは、添付の「ユースケースの項目」のドキュメント内のフォーマット・設計ルールに従い、対象のユースケースのみを出力してください。

# ガイドライン
- すべての項目を必ず記載し、記載順も上記に従ってください。
- 項目が生成できない場合は、その理由を簡潔に明記し、出力フォーマットは維持してください。

## ユースケースの項目

### 1. **ユースケース名 (Use Case Name)**
- 簡潔で明確な名前（例：「商品をカートに追加する」）

### 2. **ユースケースID (Use Case ID)**
- 一意な識別子（例：UC-001）

### 3. **目的 (Goal / Description)**
- ユーザーがこのユースケースを通じて達成したい目的

### 4. **アクター (Primary Actor)**
- このユースケースを実行する主体（例：顧客、管理者、外部システム）

### 5. **ステークホルダーと関心事 (Stakeholders and Interests)**
- 各ステークホルダーとその関心事（例：顧客は迅速なレスポンスを期待）

### 6. **前提条件 (Preconditions)**
- ユースケースが開始される前に満たされているべき条件

### 7. **終了条件 (Postconditions)**
- 成功時と失敗時のシステムの状態

### 8. **トリガー (Trigger)**
- ユースケースが開始されるきっかけ（例：ユーザーが「購入」ボタンを押す）

### 9. **基本フロー (Main Success Scenario / Basic Flow)**
- 正常系のステップバイステップの流れ

### 10. **代替フロー (Alternative Flows)**
- 条件分岐や例外処理の流れ（例：在庫切れ時の処理）

### 11. **例外フロー (Exception Flows)**
- エラーや障害が発生した場合の処理

### 12. **ビジネスルール (Business Rules)**
- このユースケースに関連する業務ルールや制約

### 13. **UI/UX要件 (Optional)**
- 関連する画面やインタラクションの概要（ワイヤーフレームなど）

### 14. **非機能要件 (Non-functional Requirements)**
- パフォーマンス、セキュリティ、可用性などの要件

### 15. **関連ユースケース (Related Use Cases)**
- このユースケースと関係する他のユースケース

### 16. **メモ・補足情報 (Notes and Issues)**
- その他の注意点、未解決の課題など
```

## Step 3. 画面とAPIとデータモデルの作成

ユースケースの情報があれば、画面のマッピング表とデータモデルが作成できます。
全体を把握する必要がなければ、ユースケースは指定して絞った方が良いです。


### Step 3.1. データモデル作成

データモデルの作成は大変便利です。ここまでの業務要件の流れから抽出することで、プロトタイプとして利用者が利用イメージが湧きやすくなり自分事として捉えやすくなります。また、既存のデータソースとの接続が難しい場合など、それに引きずられること無く、アプリケーションの開発に入っていけます。

```text
対象のユースケース（JBO-UC-001: 電子申請・電子決裁）について、ソフトウェアエンジニアが実装できる詳細なレベルのデータモデルと、日本語のサンプルデータを作成してください。
```

### Step 3.2. マッピング表の作成

画面とAPIとデータの関連性を整理します。

```text
対象のユースケース（JBO-UC-001: 電子申請・電子決裁）を、マイクロサービスアーキテクチャで構築するアプリケーションの、
画面 → **画面内機能 → 画面内処理 or API呼び出し → APIが管理するデータ
のマッピングを、わかりやすい表形式で作成してください。
マイクロサービスアーキテクチャの原則を必ず守って設計を行ってください。

## 要件：

- 各画面ごとに、以下を整理すること
  - 画面名
  - 画面内の主要な機能（例：検索、登録、削除など）
  - その機能が「画面内処理」か「API呼び出し」かを明示
  - API呼び出しの場合は、エンドポイント、HTTPメソッド、主要パラメータを記載
  - APIが管理するデータ（SoT）を明記
- 最後に、APIサービスと管理データの責務マッピング表も追加してください

さらに、可能であれば以下も含めてください：

- 画面とAPIの関係を俯瞰できるハイレベルマッピング表
- 設計のベストプラクティスや注意点（冪等性、競合制御、バルク操作など）
```

作業手順の中で**機能やAPI**の概要を作成している点をお忘れなく。
この


### Step 3.3. 生成AIに最適化した画面作成のためのプロンプトの作成

画面定義書は、既存のドキュメントを強く意識している「人」が理解しやすいであろう構造化情報として作成されています。

生成AIへPromptとして渡す場合は、より生成AIが理解しやすいように、以下の様なPromptを作成することをお勧めします。

対象としては、以下があげられます。
- GitHub Spark

```text
# 目的
ソフトウェアでの実装のための画面の指示書を作成します。

# タスク
- 作成の対象は、{画面名}です。
- 作成する内容は、{指示書のガイドライン}をチェックリストとしてだけ**必ず**遵守して、深く分析・解釈してください。書式は{指示書のガイドライン}とは別でよいです。
- 作成する書式などについては{最適化された指示書の例}も必ず参考にしてください。
- 先に作成した{日本語のサンプルデータ}を、データとして必ず追記してください。データが入っている事で、画面の作成後に、即座に利用することができるようにしてください。
---

# 指示書のガイドライン

## 1. 全体評価

* プロンプトの目的とゴールの明確性を評価する。
* 受け入れ基準がテスト可能であることを示す。
* 機能追加の段階性（基礎 → 拡張 → 制約）を分析する。
* 曖昧さを取り除き、非機能要件・公平性・UXを補強する。

## 2. 仕様の厳密化

### コア機能

* **入力**：ユーザー単語リスト、任意のグリッドサイズ（デフォルト12×12、範囲6～20）。
* **配置**：8方向（N, NE, E, SE, S, SW, W, NW）、前後両向き。配置失敗時は一定回数リトライ。未使用セルはA–Zランダム。
* **検出**：マウス（クリック→ドラッグ→離す）、タッチ（長押し→スワイプ→離す）。直線一致で「発見」状態。
* **完了**：全語発見でタイマー停止、「新規パズル作成」ボタンを提示。

### タイマー & リーダーボード

* **開始**：生成直後に自動スタート。
* **停止**：最後の語発見時に停止。
* **フォーマット**：`MM:SS.mmm`（ms精度、表示は四捨五入）。
* **記録項目**：名前、時間、語数、サイズ。
* **ソート**：昇降順切替可能（時間／語数／名前）。同率時は**時間→語数→名前**でタイブレーク、安定ソート必須。
* **公平性**：サイズ×語数ごとにランキングを分離。

### 入力制約 & エラー

* **単語長 ≤ min(行, 列)**。違反時は「語はサイズ以下にしてください」と即時エラー。
* **文字種**：A–Z（大文字小文字非区別、空白/ハイフン除去）。
* **重複語**：一意化または警告のいずれかを仕様化。
* **最大語数**：例 5–20、超過や配置不能時は「語数を減らすかサイズを増やしてください」。

### データモデル & アルゴリズム

* **モデル**：`Grid`, `Word{text, path}`, `Score{name, timeMs, wordCount, gridSize}`。
* **配置**：ランダム起点＋方向、失敗時リトライ（上限=面積×2）。
* **乱数**：毎回変化（将来拡張でシード固定可）。
* **性能目安**：12×12で10語 → 100ms以内に生成。

### UX / A11y

* **キーボード操作**：矢印移動＋Enterで選択、Escで解除。
* **色覚対応**：色＋下線／太字併用。
* **スクリーンリーダー**：`aria-live`で進捗を読み上げ。
* **フォーカス管理**：タブ順序保証。

### セキュリティ & プライバシー

* 名前入力はサニタイズ、最大長24文字、制御文字禁止。
* 保存範囲はローカルのみ。共有や送信は行わない。

### 非機能要件

* 反応速度：検出レスポンス16ms以内。
* 永続化：localStorageに100件まで履歴保存。
* オフライン：PWA拡張可能。

### アンチ要件（除外範囲）

* ヒント機能、マルチプレイ、サーバ同期、厳格チート検出は含めない。

## 3. 曖昧さと解決

* 「斜め」＝NE／NW／SE／SW の4方向と明記。
* 「ドラッグ」＝連続セル追従操作と定義。
* タイマーは一時停止なし。
* 同率スコアは必ず単一順位を決定。

## 4. 受け入れ基準例（Gherkin風）

* **語長境界**：10×10で長さ10 → 成功。長さ11 → エラー表示。
* **操作**：連続セルドラッグで一致 → 発見状態＋バンクにチェック。
* **タイマー**：生成直後に`00:00.000`から加算開始、全語発見で停止。
* **ランキング**：時間昇順、同率は語数→名前順。

## 5. リスクとトレードオフ

* 語数過多×小サイズ → 自動拡大提案。
* 色のみ強調はNG → 装飾併用で補正。
* ローカル保存はチート耐性低 → 許容範囲と明示。

## 6. 拡張余地

* 難易度プリセット、カテゴリ別語リスト、辞書検証、シード固定、PWA対応、共有ランキングAPI。

## 7. 最終チェックリスト

* ゴール／完了条件／操作が一読で明確か？
* 8方向＋逆方向が定義されているか？
* 境界値とエラーメッセージが明文化されているか？
* タイマー仕様（開始・停止・丸め）が厳密か？
* リーダーボードが公平で、ソート＋同率処理が定義されているか？
* A11y・非機能要件が網羅されているか？
* スコープ外が宣言されているか？

---

# 最適化された指示書の例
- Please create a word search game. The game should take in a set of words from the user, then create a word search puzzle containing those words, as well as a word bank listing the words. Words in the puzzle can be horizontal, vertical, diagonal, forwards, and backwards, and are "found" when the user clicks and drags their mouse across them. Once all words are found, give the user the option to create a new puzzle.
- Please add a leaderboard and a timer to the game. The timer should start when the user generates a new puzzle, then stop when all words are found. The user should then be able to enter their name, and their name, time, and the number of words in their puzzle should be displayed on the leaderboard. The leaderboard should be sortable in ascending and descending order by each of the three categories.
- Please prevent users from entering words longer than the number of rows or columns in the puzzle. Additionally, add an option to change the size of a puzzle. If the user tries to enter a word that's longer than the current size of the puzzle, display an error message telling them that provided words must be less than or equal to the size of the puzzle.
```

参考:
https://docs.github.com/en/copilot/tutorials/easy-apps-with-spark

### (Option) Step 3.4. 画面コンポーネントの設計

選択した画面をComposite UIにするために、画面コンポーネント設計を行います。

```text
詳細な画面コンポーネント設計（Atomic）を作成してください。
```

### (Option) Step 3.4. 画面定義書の作成

リストアップされた中から、1つだけ選択して、画面定義書を作成します。

```text
# 目的
対象の{画面ID :	画面名}について、{画面定義書}のフォーマット・設計ルールに従って、プログラマーが実装できる詳細かつ深さの画面定義書のドキュメントを作成してください。

## 画面定義書

### 0. メタ情報（前提・識別子）
- **画面ID**：`SCREEN_xxx`
- **名称**：例）ユーザー一覧
- **URL/ルート**：例）`/users?query&sort&page`
- **対象ロール/権限**：例）Admin, Manager（RBAC/ABAC要件）
- **依存API/テーブル**：例）`GET /api/users`, `users`, `roles`
- **状態モデル**（主要ストア/キャッシュキー）：例）`users:list`, `filters`, `selection`
- **前提条件**：例）認証済、組織選択済
- **非機能要件**（概要）：性能目標、A11y、i18n、レスポンシブ方針

### 1. 目的（ユーザー価値・完了条件）
- **目的**：この画面でユーザーが達成すべきこと（例：ユーザーの検索・閲覧・一括操作）
- **完了条件（Definition of Done）**：成功シナリオ/代替シナリオ/中断条件
- **主要ユースケース**：Top3の業務フロー（As-Is→To-Beの差分があれば記載）

### 2. 主なコンポーネント（UI構成・条件表示・データバインド）
- **レイアウト**：ヘッダー/サイドバー/メイン/フッター、ブレークポイント別挙動
- **コンポーネント一覧**（ID、種別、データバインド、可視条件、A11y）
  - 例）`searchForm`（フォーム）：`filters` に双方向バインド、`role=search`、EnterでSubmit
  - 例）`dataGrid`（一覧）：`users` コレクションにバインド、仮想スクロール、行選択可
  - 例）`bulkActions`（ツールバー）：`selection.length > 0` で可視
- **状態遷移**：`idle → loading → success|error`、ローディング/空/エラー表示仕様
- **フォーカス順**：タブ順序、キーボード操作、スクリーンリーダーラベル

### 3. 入力・検証（フィールド仕様・ルール・メッセージ）
> **フィールド仕様表**（必要に応じて追加列可）

例)
| フィールドID | ラベル | 型/フォーマット | 必須 | 入力制約（長さ/範囲/パターン） | 依存/相関 | 既定値 | 検証タイミング | エラーメッセージ（i18nキー） | A11y（説明/ARIA） | セキュリティ（PII/マスク） |
|---|---|---|---|---|---|---|---|---|---|---|
| `email` | メール | email | ◯ | RFC準拠 | 一意性 | なし | onBlur + onSubmit | `errors.email.invalid` | `aria-describedby=emailHelp` | PII、表示時マスク |
| `password` | パスワード | password | ◯ | 8–64/複合規則 | なし | なし | onChange強度、onSubmit | `errors.password.weak` | 非表示/トグル | 機密、保存禁止 |

- **同期検証**：必須/型/桁数/パターン/相関（開始日≦終了日 等）
- **非同期検証**：重複チェック、存在確認、権限チェック、レート制限
- **エラー表示**：フィールド内/サマリー/トースト、文言、一貫したUXルール
- **マスキング/フォーマッタ**：入力中と表示時の差、IME考慮

### 4. アクション（イベント→処理→API→結果反映）
- **イベント一覧**（発火条件、ハンドラ、ガード条件）
  - 例）`searchForm.submit` → `GET /api/users`（クエリ構築、キャンセル可能）
  - 例）`dataGrid.rowClick` → 詳細へ遷移（`/users/:id`）
  - 例）`bulkActions.delete` → 確認モーダル → `DELETE /api/users`（一括）
- **APIコール仕様**（メソッド・エンドポイント・ペイロード・ステータス・エラー）
- **結果反映**：楽観UI/悲観ロック、キャッシュ無効化/部分更新、Undo/リトライ方針
- **ナビゲーション**：戻る/進む、ルーティングガード（未保存警告）
- **並行制御**：多重送信防止、デバウンス/スロットリング、同時編集中の衝突解決
- **権限**：操作ごとのRBAC/ABAC条件（UI非表示 vs 非活性 vs 実行時ガード）

### 5. 通知・連携（ユーザー通知・外部システム）
- **UI通知**：トースト/バナー/モーダル、重要度/自動クローズ、フォーカス移動
- **システム通知**：メール/Slack/Teams、テンプレートID、送信トリガー、再送戦略
- **外部連携**：Webhook（URL、ヘッダー、署名）、メッセージング（キュー/トピック、イベント名、ペイロードスキーマ）
- **CMS/翻訳連携**：文言キー、動的差し込み、言語フォールバック

### 6. 監査（証跡・ログ・保持・可観測性）
- **監査対象イベント**：誰が/いつ/何を/どこで/結果/相手先（IP/UA/リクエストID）
- **ログスキーマ**：`traceId`, `spanId`, `actorId`, `tenantId`, `screenId`, `action`, `before`, `after`, `reason`
- **PII/機微情報**：保存禁止/ハッシュ化/トークナイズ/マスキングの規約
- **保持期間/削除**：法令/社内規定準拠、エクスポート/開示リクエスト対応
- **改ざん防止**：WORMストレージ/署名チェーン/整合性チェック
- **可観測性**：メトリクス（TTFB、FCP、INP、失敗率、再試行率）、ダッシュボード/アラート閾値

## 非機能要件（共通追記セクション：推奨）

- **性能予算**：FCP < 2.0s、INP < 200ms、API 95p < 300ms、クエリ応答 < 500ms  
- **アクセシビリティ**：WCAG 2.2 AA、キーボード操作完備、ラベル/説明、コントラスト  
- **レスポンシブ**：主要ブレークポイント・列折り返し・コンパクト行高の定義  
- **i18n**：文言キー、数字/日付/通貨フォーマット、方向性（LTR/RTL）対応の有無  
- **エラー/空/ローディング**：必ずモック含め視覚設計（スクルトン/プレースホルダ）  
- **セキュリティ**：CSRF/XSS対策、CSP、権限漏れのUI非表示、秘密情報のログ禁止  
- **テレメトリ**：画面別PV/滞在、主要CTAのCTR、失敗率、再試行率、NPSトリガー  
- **テスト観点**：ユニット/コンポーネント/E2E、主要フローと境界値、A11y自動テスト

```

## Step.4. マイクロサービスの定義書の作成

[Step 3.2. 画面マッピング表の作成](./要求定義作成.md/#step-32-画面マッピング表の作成) で作成した画面マッピング表を作業ファイルとして添付します。

### Step.4.1. マイクロサービスの定義書の作成

Prompt:

```text
{マイクロサービス名}を対象として、{マイクロサービス定義書}に準拠したマイクロサービスのドキュメントを作成してください。

# ガイダンス
- 作成したドキュメントは**GPT‑5 のコード生成に直結する仕様束**になるようにしてください。

## マイクロサービス定義書

### 1. **サービスメタ情報**
- **サービス名／短縮名**：例）Template Service（TPL）  
- **概要（One-liner）**：何を「いつ・誰に・なぜ」提供するか。  
- **責務（Do）／非責務（Don’t）**：境界の明示。承認ルーティング**実行**は非責務 等。  
- **利害関係者・主要ペルソナ**（任意）：管理者、部門管理者、申請者、監査。

### 2. **ビジネス能力・コンテキスト**
- **対象ドメインとユースケースの対応表**：FR-002-01 下位要件とのトレーサビリティ。  
- **ライフサイクル**：ドラフト→レビュー→公開→廃止（状態と遷移イベント）。

### 3. **公開インターフェース（同期）**
- **API スタイル**：REST（JSON/UTF‑8）（※GraphQL 等の場合は理由）。  
- **リソース一覧（概要）**：`/templates`、`/types`、`/fields`、`/diff`、`/preview` …（**動詞ではなく名詞**で統一）。  
- **操作粒度**：作成／取得／検索（フィルタ・ソート・ページング規約）／公開／廃止／差分取得／プレビュー。  
- **冪等性**：`Idempotency-Key` の扱い、重複作成の基準。  
- **エラー語彙（概要）**：`TPL-VAL-001 必須欠落`、`TPL-STATE-001 状態不正` などの**コード体系と責務境界**。  
> ※後でコード生成するため、ここには**OpenAPI の骨子**（パス・ステータス・代表スキーマ名）だけを置く。

### 4. **公開インターフェース（非同期）**
- **ドメインイベント（発行）**：`TEMPLATE.PUBLISHED`、`TEMPLATE.RETIRED` など。  
  - 目的、発火条件、**最小ペイロード項目**（識別子、版、適用開始、破壊的変更フラグ 等）。  
- **サブスクライブ（受信）**：MDM 更新、承認ルール変更、インボイス検証結果 等。  
- **配信保証**：少なくとも 1 回／順序性／再送ポリシー（概念レベル）。  
> ※後でコード生成するため、ここには**AsyncAPI の骨子**（チャンネル名・メッセージ名・キー属性）だけを置く。

### 5. **データ所有・モデル（概念）**
- **主エンティティと所有者**：Template（本サービス所有）、RequestType（同）、AttachmentPolicy（同） 等。  
- **整合性・一意性ルール**：同一 `typeId` で同時点に有効な版は1つ、破壊的変更は新規版 等。  
- **データ分類／個人情報**：PII/非PII、電帳法検索キーの取り扱い。  
- **マルチテナンシ／スコープ**：全社／部門／ロール／属性（可視性の粒度）。

### 6. **セキュリティ・権限**
- **認証**：OIDC/SSO（MFA 前提）。  
- **認可**：RBAC/ABAC（属性例：部門 ID、役職、委任期間）。  
- **暗号化**：転送中 TLS、保存時 KMS、添付はオブジェクトストレージのサーバサイド暗号化。  
- **監査**：操作（作成／編集／公開／廃止／ロールバック）の**不可改ざん記録**（何を・誰が・いつ・どこから）。

### 7. **外部依存・統合**
- **依存先と契約**：  
  - MDM/HR（組織・職位・権限・委任）  
  - 承認エンジン（RuleSet 参照のみ）  
  - 電帳法対応ストレージ／タイムスタンプ  
  - インボイス検証 API  
  - ERP/会計/契約台帳/DWH  
- **フォールバック戦略**：外部検証障害時は暫定許可→**後続検証キュー**、時間切れ時のポリシー。

### 8. **状態遷移・ビジネスルール**
- **状態機械（概念図）**：Draft → InReview → Published → Retired（RollBack 可否）。  
- **条件分岐の原則**：金額・カテゴリ・海外判定等に基づく動的表示／必須化の**安全側フォールバック**。  
- **公開可否ゲート**：電帳法検索キーが欠落するテンプレは公開不可 等。

### 9. **非機能・SLO（概念）**
- **可用性／パフォーマンス目安**：例）p50/p95 レイテンシ、同時編集想定、イベント伝播遅延上限。  
- **スケーラビリティ**：読み主体（一覧・プレビュー）最適化、書き（公開）時の直列化。  
- **運用監視**：メトリクス（差戻し率、滞留時間、公開後エラー率）、トレース、構成変更監視。  

### 10. **バージョニング／互換性**
- **API 版付け**：`/api/v1/...` の原則、後方互換の維持と**廃止告知期間**。  
- **テンプレ版と適用範囲**：新規起票には最新版、既存案件は旧版維持／ドラフトの自動マイグレーション方針（案内のみ、強制なし）。  
- **イベント版付け**：メッセージの `schemaVersion` と互換規約。

### 11. **エラー・レート制御・再試行**
- **エラー体系（概要）**：`TPL-VAL-xxx`（検証）、`TPL-STATE-xxx`（状態）、`TPL-API-xxx`（外部障害）など**命名規約**。  
- **レート制限**：管理操作（公開・廃止）は保守的、読み取りは緩め。  
- **再試行ポリシー**：クライアント／サーバの責務分界、**冪等性キー**利用時の再送許容。

### 12. **設定・フラグ**
- **機能フラグ**：ローカライズ有効化、OCR 有効化、破壊的変更ガード。  
- **構成キー**：外部 API タイムアウト、最大添付サイズ、OCR リトライ回数（値はここでは**未記載**）。

### 13. **移行・初期データ（任意）**
- **初期テンプレの投入計画**、旧システムからの**読み替え原則**、識別子のマッピング方針。

### 14. **テスト指針（概念）**
- **契約テスト**（Provider/Consumer）、**状態遷移テスト**、**ローカライズの可用性テスト**、**監査改ざん検知テスト**。  
- **テストデータ原則**：サンプルテンプレと最小必須証憑。

### 15. **運用・リリース（概念）**
- **デプロイ戦略**：ローリング／カナリア（公開・廃止の**時間指定**に対応）。  
- **ロールバック**：API とデータの整合を保つための**版単位**ロールバック手順（概念）。  
- **通知・チェンジマネジメント**：リリースノート、影響分析、対象ユーザへの配布ポリシー。

### 16. **リスク・オープン課題**
- 例：外部検証 API の SLA 未定義、MDM の属性欠落、部門差分の継承衝突 等。

## 17. **画面・操作・API・イベント マッピング**
- **目的**：UI（画面）とマイクロサービスの責務を明確化し、疎結合な設計を担保する。  
- **マッピング表**：
- **原則**：  
  - 1画面＝1主要サービス（UIロジックは集約しない）  
  - 複数サービスを呼ぶ場合は**BFF（Backend for Frontend）**でオーケストレーション  
  - 画面IDはFRDやUI設計書とトレーサブルに  

### 付録 A（コード生成用の“骨子”を添付）
- **OpenAPI（スケルトン）**：パス・メソッド・代表スキーマ名のみ。  
- **AsyncAPI（スケルトン）**：チャンネル名・イベント名・キー属性のみ。  
- **JSON Schema（概念版）**：`Template`, `FieldDefinition`, `AttachmentPolicy` の最低限属性。  
- **用語集／語彙**：ラベル、状態、エラーコードの辞書。

```


### (Option) Step. 4.2. 機能要件作成

機能要件書を作成します。

[Step 3.2. 画面マッピング表の作成](./要求定義作成.md/#step-32-画面マッピング表の作成) で作成した画面マッピング表を作業ファイルとして添付します。

情報量が多い場合は、ファイルを分割した方が、より詳細な情報を作成してくれます。

```text
# 目的
- 指定された機能要件（JBO-FR-001: 電子申請）のみについて、{機能要件書の項目}に沿った、ソフトウェアとして実装するための可能な限り詳細かつ具体的かつ深い機能要件書を作成してください。

## 機能要件書の項目

### 1. **はじめに（Introduction）**
- **目的（Purpose）**  
  ドキュメントの目的と読者の想定。
- **スコープ（Scope）**  
  対象となるシステムやアプリケーションの範囲。
- **定義と略語（Definitions and Acronyms）**  
  用語の定義、略語の説明。

### 2. **全体概要（Overall Description）**
- **ビジネス背景と目的（Business Context and Goals）**
- **ユーザーの概要（User Characteristics）**
- **前提条件と制約（Assumptions and Constraints）**
- **依存関係（Dependencies）**

### 3. **機能要件（Functional Requirements）**
各機能をユースケースまたは機能単位で記述：

- **機能ID（Requirement ID）**
- **機能名（Function Name）**
- **説明（Description）**
- **入力（Inputs）**
- **出力（Outputs）**
- **前提条件（Preconditions）**
- **事後条件（Postconditions）**
- **例外処理（Exception Handling）**
- **関連ユースケース（Related Use Cases）**

### 4. **ユーザーインターフェース要件（UI Requirements）**
- 画面レイアウト、ナビゲーション、入力項目、バリデーションルールなど。

### 5. **外部インターフェース要件（External Interfaces）**
- **API仕様**
- **外部システムとの連携**
- **データフォーマット（JSON, XMLなど）**

### 6. **データ要件（Data Requirements）**
- **データモデル（ER図など）**
- **データ項目の定義**
- **データの整合性ルール**

### 7. **セキュリティ要件（Security Requirements）**
- **認証・認可**
- **データ暗号化**
- **監査ログ**

# ガイドライン
- はじめに行う作業の概要を、3～7項目程度のコンセプチュアルなチェックリストとして簡潔に示してください。
```

## (Option) コンポーネントモデル作成

共通機能ですね。

```text
{機能要件}の中のデータやフロー、画面など、共通化できるコンポーネントをリストアップしてください。
```
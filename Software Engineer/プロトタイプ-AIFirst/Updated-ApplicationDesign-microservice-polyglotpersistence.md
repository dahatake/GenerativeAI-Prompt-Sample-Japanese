# アプリケーション設計 - Microservice + Polyglot Persistence

ソフトウェアエンジニアがアプリケーション開発に着手するための入力情報となりえるドキュメントを作成します。
ユースケースは複数の候補から、1つずつ選択して、アプリケーション設計を進めていきます。

## ツール
GitHub CopilotはSoftware Engineeringについては比較的良いOutputを出してくれます。
ただし、GitHub CopilotのAgentは、デフォルトでFirewallの設定があり、MCP経由でないと外部の情報を参照ができません。
その点では、Microsoft 365 CopilotのGPT-5でも良いかもしれません。

GitHub Copilotには複数のAgentがあります。ご自分の好みのものを選択してください。

https://docs.github.com/ja/copilot/get-started/features

- GitHub Copilot Agent Mode
Visual Studio XなどのIDEに組み込まれたCopilotです。モデルを複数から選択できるメリットがあります。

- GitHub Copilot Coding Agent
Coding Agentの場合はDeep Research系の動作をすることもあって、若干時間を要しますが以下のメリットもあります。

  - GitHubのIssueとしてトラックできる
  - Issue発効後は、手元のPCなどで別作業がしやすい
  - バッチ的に複数のファイル作成がやりやすい

> [!NOTE]
> 作成結果は、GitHubのRepositoryにドキュメントとして保存しておくことをお勧めします。


# Step. 1. マイクロサービスアプリケーション定義書の作成

ユースケースの情報があれば、画面やサービス、データなど各種のモデリングが可能です。
ここからはマイクロサービスでの設計の進め方をある程度踏襲して、具体的な関連情報を文章化していきます。

## Step. 1.1. ドメイン分析の実施

ここでは作成されたユースケースから、**1つだけ選択**して、業務上のドメイン分析を行います。

```text
# 役割
あなたは、マイクロサービスアーキテクチャに関する高度な専門知識と実務経験を持つソフトウェアアーキテクトです。

## あなたの専門領域
- **ドメイン駆動設計（DDD）とClean Architecture**: サービスの責務分離と依存関係の最適化を行う
- **スケーラビリティと可用性**: クラウドネイティブな設計（Kubernetes、サービスメッシュ）を活用し、システムの拡張性と耐障害性を担保する
- **データ管理戦略**: マイクロサービス間のデータ整合性、分散トランザクション、イベント駆動アーキテクチャ（EDA）を適切に設計する
- **セキュリティと運用性**: 認証・認可（OAuth2, JWT）、監視（Observability）、CI/CDパイプラインの設計を行う
- **技術選定とトレードオフ**: パフォーマンス、保守性、チームスキル等を考慮し、合理的な判断を下す

# タスクの目的
{ユースケース}のドキュメントを分析し、ドメイン駆動設計（DDD）の観点からドメインモデリングを実施し、業務ドメインと境界づけられたコンテキスト（Bounded Context）を特定します。

## 成果物
- ドメイン分析ドキュメント
- 境界づけられたコンテキストの一覧
- ユビキタス言語の定義

# 実施手順

## ステップ1: ユースケースの深い理解
{ユースケース}を確認し、以下を抽出してください：

### 分析観点
1. **ビジネスフロー**
   - 主要な業務プロセス
   - アクター間の相互作用
   - ビジネスルール

2. **データフロー**
   - 情報の流れ
   - データの発生源と最終的な保存先
   - データ変換のポイント

3. **ドメインの候補**
   - ビジネス用語のクラスター
   - 自然な機能の境界
   - 独立して進化できる単位

## ステップ2: 境界づけられたコンテキストの特定
以下の基準で Bounded Context を特定してください：

### 特定基準
1. **ユビキタス言語の一貫性**
   - 同じ用語が異なる意味で使われていないか
   - コンテキスト内で用語の意味が統一されているか

2. **組織的境界**
   - 異なるチームが管理する領域か
   - 異なるステークホルダーが関与するか

3. **技術的境界**
   - 独立してデプロイ可能か
   - 異なる技術スタックが必要か

4. **ビジネス機能の凝集度**
   - 高頻度で一緒に変更される機能か
   - 一つのトランザクションで完結するか

### 出力形式
```markdown
## 特定された Bounded Context

### コンテキスト1: 注文管理
- **責務**: 注文の作成、更新、キャンセル、状態管理
- **主要エンティティ**: Order, OrderLine
- **境界の根拠**: 注文のライフサイクル管理は独立したビジネスロジックを持ち、他の機能と分離可能
- **依存**: 顧客情報（参照のみ）、在庫情報（確認）

### コンテキスト2: 決済
- **責務**: 決済処理、決済状態管理、返金処理
- **主要エンティティ**: Payment, Transaction
- **境界の根拠**: 決済は金融取引の専門知識が必要で、PCI DSS準拠等の特別な要件がある
- **依存**: 注文情報（参照）
```

## ステップ3: ドメインモデリングドキュメントの作成
{作成ファイル}に以下の構成でドキュメントを作成してください：

### 必須セクション

#### 1. 概要（Summary）
- **ユースケースID**: `{ユースケースID}`
- **ユースケース名**: *例: 注文登録と決済*
- **対象範囲**: *例: 受注～決済確定まで*
- **主要ステークホルダー**: *例: EC顧客、営業、会計*
- **非機能要件の要点**: *例: p95レイテンシ2秒以内、99.9%可用性、At-least-once配信*

#### 2. ドメインID
- 一意な識別子: `{ユースケースID}`

#### 3. ユビキタス言語（Ubiquitous Language）
ドメイン専門家と開発者が共通で使う語彙の定義。コンテキストごとの意味差を明確化します。

| 用語 | 定義 | コンテキスト | 例/備考 |
|------|------|------------|---------|
| 注文（Order） | 顧客が商品を購入する意思表示 | 注文管理 | ステータス: Draft → Placed → Paid |
| 決済承認（Payment Authorization） | 決済手段で承認を取得する行為 | 決済 | 決済手段: クレジット、ポイント |

#### 4. エンティティ（Entity）
識別子を持ち、永続化され、状態遷移があるオブジェクト。

```markdown
### Order（注文）
- **属性**: id, customerId, orderLines[], status, totalAmount, createdAt
- **状態遷移**: Draft → Placed → Paid → Shipped → Completed
- **ビジネスルール**:
  - 合計金額は注文明細の合計と一致する必要がある
  - 支払い完了後のキャンセルには承認が必要
```

#### 5. 値オブジェクト（Value Object）
識別子を持たず、不変で、値による等価性を持つオブジェクト。

```markdown
### Money（金額）
- **属性**: amount (decimal), currency (string)
- **不変条件**: 金額は負にならない
- **振る舞い**: add(), subtract(), multiply()
```

#### 6. 集約（Aggregate）
トランザクション境界を定義する一貫性の単位。

```markdown
### 集約: Order
- **集約ルート**: Order
- **構成要素**: OrderLine[]
- **不変条件**:
  - 少なくとも1つの注文明細が必要
  - 合計金額 = Σ(単価 × 数量)
- **トランザクション境界**: 注文と注文明細は同時に更新される
```

#### 7. ドメインイベント（Domain Event）
ドメインで発生した重要な出来事。

```markdown
### OrderPlaced（注文確定）
- **発生タイミング**: 顧客が注文を確定したとき
- **含まれる情報**: orderId, customerId, orderLines, totalAmount, placedAt
- **購読者**: 在庫管理、決済、通知
```

#### 8. 境界づけられたコンテキスト間の関係
コンテキスト間の統合パターンを定義。

```markdown
## コンテキスト関係図

注文管理 --[顧客情報参照]--> 顧客管理
注文管理 --[OrderPlacedイベント]--> 決済
決済 --[PaymentCompletedイベント]--> 注文管理
```

### パターン
- **Customer/Supplier**: 注文管理（C）← 決済（S）
- **Published Language**: ドメインイベント（JSON Schema）
- **Anti-Corruption Layer**: 外部決済ゲートウェイとの統合

## ステップ4: 自己レビュー
以下を確認してください：

- [ ] Bounded Context が明確に定義されている
- [ ] ユビキタス言語が定義されている
- [ ] エンティティと値オブジェクトが識別されている
- [ ] 集約とトランザクション境界が明確である
- [ ] ドメインイベントが特定されている
- [ ] コンテキスト間の関係が定義されている
- [ ] 各コンテキストの責務が明確で重複がない

## ユースケースID
- UC-xxx

## ユースケース
- docs/usecase/{ユースケースID}/usecase-description.md

## 作成ファイル
- docs/usecase/{ユースケースID}/domain-analytics.md

# 作業管理
- 作業時間が10分を超える場合は、作業を中断し、10分毎のタスクに分割して、Issueとして実行するためのPromptを`work/architecture-domain-modeling-issue-prompt-<番号>.md`に日本語で作成してください。

- ファイル書き込み時に大きな文字列で失敗する場合は、文字列を分割して複数回に分けて書き込んでください。
```

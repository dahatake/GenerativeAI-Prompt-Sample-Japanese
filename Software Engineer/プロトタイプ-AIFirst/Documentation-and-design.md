# 要求定義 - AI Agentが作業しやすいPromptの作成

事業のアイディア、議事録、プロジェクトプランなどから、ソフトウェアエンジニアがアプリケーション開発に着手するための入力情報となりえるドキュメントを作成します。

GitHub Copilot AgentへのIssue候補でもあります。

https://docs.github.com/ja/enterprise-cloud@latest/copilot/using-github-copilot/coding-agent/about-assigning-tasks-to-copilot

# 作戦

アプリケーションは何らかの**課題**の解決のためのツールとして価値を発揮します。
そのため、課題の抽出に力点をあてて話を進めていきます。

幾つか**Option**としている部分があります。これらはこれまでのSoftware Engineeringの過程でよく作成されているドキュメントになります。AI Firstのアプローチの場合は、必ずしも必要ではないかもしれません。そのために作成の**優先度は下げても構いません**。

# ツール

ツールは、最近のLLMであれば、どれでもそれなりにドキュメントを作成してくれます。

おすすめツール:
- (最強) Microsoft 365 Copilot Researcher
    - https://blogs.windows.com/japan/2025/04/14/introducing-researcher-and-analyst-in-microsoft-365-copilot/
    - Researcherが使える方は、こちらの利用を強くお勧めします。より詳細なドキュメントの作成をしてくれますし、何よりその理由の説明のドラフトの作成が強力です。

- Microsoft 365 Copilot
    - https://www.microsoft.com/ja-jp/microsoft-365/copilot/copilot-for-work


ドキュメント化することが大事です。
- テキストのファイル: 各Promptの中で**要求定義**など、そのドキュメントが世間一般で通じる名称、つまり、LLMがどんなドキュメントなのかの判断がつきやすいです
- Wordなど: 長文であっても、章ごとに**意味のある塊**としてLLMに伝えやすくなります。また、OneDriveなどに置いておけば、バックアップ、バージョン管理、共同作業などがしやすくなります。Microsoft 365 Copilotの場合は、そのファイルをアップロードあるいはOneDrive上のファイルの参照が容易にできるため、入力ドキュメントの指定としての正確性が増します。
- 一つ一つのPromptの出力文字列が長くなる傾向があります。そのため以下のタイミングで、出力結果をMicrosoft 365のLoopに出力するなどして、別の新規の会話で作業を継続することも検討してください。これは将来のモデルの能力が高まれば改善される可能性もあります。


各ステップでの出力ですが、以下の様に使用すると良いかと思います。

- 通常のCopilotなど

    - チャットを継続してください

- Researcherなど、Deep Research 系
    - チャットは可能な限り1つのチャットの中で処理をしてください。コンテキストが引き継がれて、よりよい出力結果を得られやすいです。
    - それでも通常と比較すると、会話の回数は少なくなります。トークン数が多すぎるためです。4-5回程度の会話で限界かもしれません。
    - チャットの成果物は、Loopに出力して、その後Wordに出力することをお勧めします。そのWordのファイルを次の入力の情報として使ってください

## Step.1 対象事業の選定

これは、アプリケーション開発対象の事業が何か決まっていない場合に使います。
ここではAs-IsとTo-Beを一度に作成します。もし、出力結果が多すぎる場合は、以下の様にステップを分割することをお勧めします😊

- おススメツール
  - Microsoft 365 Copilot リサーチルール
  - 社内外の情報収集に強いです。これ以降はRAGしたくないので、この文章に可能な限り情報を詰め込みたいです。

```text
# 役割
- あなたはMBAを保有している、世界最高峰クラスのビジネス戦略コンサルタントとして振舞ってください。

# 目的
- 私は{企業名}の事業の課題とその解決策について調査しています。
- {企業名}の過去10年間の事業分析を行って、{事業分析レポート構成}に沿った論理的かつ説得力のある詳細なレポートを作成してください。

# ガイドライン
- まず、実施内容の簡潔なチェックリスト（3～7項目）を箇条書きで示してください。それぞれの項目は概念的なもので、実装レベルには踏み込まないでください。

# 事業分析レポート構成

1. **エグゼクティブサマリー**
    - 調査の目的と背景
    - 主な発見と提言の要約
    - 今後のアクションの方向性
2. **内部環境分析**
    - 組織構造とガバナンス
    - 人材・スキルセット
    - オペレーション（生産、物流、品質管理など）
    - 財務状況（収益性、コスト構造、キャッシュフロー）
    - IT・デジタル活用状況
3. **顧客・製品・サービス分析**
    - 顧客セグメントとニーズ
    - 製品・サービスの提供価値（バリュープロポジション）
    - 顧客満足度・NPSなどの指標
    - 売上構成と収益性の高い製品群
4. **業務プロセス分析（As-Is / To-Be）**
    - 現行業務フローの可視化
    - ボトルネックや非効率の特定
    - 改善余地のあるプロセス領域（深く・詳細に）
5. **DX・テクノロジー活用状況**
    - 現在のデジタル化レベル
    - データ活用・分析基盤の整備状況
    - 自動化・AI導入の可能性
6. **改善提言とインパクト評価**
    - 改善施策の提案（短期・中長期）
    - 各施策のROI・KPI試算
    - 実行優先度とロードマップ案

# 出力形式・記載上の注意
- 各フィールドの内容はビジネスコンサルタント視点で論理的に記述し、詳細な説明を心がけてください。必要に応じて追加的なサブポイントは配列やリストで表現して構いません。
```

M365 Copilotを使っている場合は、出力結果を**Pageに編集**で、Loopのファイルとして保存するのが便利です。

## Step.2 ユースケース作成

事業課題から、ユースケースを作成します。

一度に全てを作成しきれない事があります。その場合は、まずは一覧を作成して、その中から、ユースケースの詳細を作成したいものを選定して、先に進みます。

### Step.2.1 ユースケース一覧作成 

Step.1 で作成したLoopのファイルを**作業コンテンツ** (添付ファイル)として追加します。

```text
# 役割
あなたは歴史上最高のSoftware EngineeringのProduct Managerです。

# タスク
- 添付ドキュメントには、ある企業の事業課題とその解決策が含まれています。

- 解決策の実現方法を慎重に検討してください。
- 実現の手段として、ソフトウェアが効果的に利用できるものと、そうでないものがあります。
- ソフトウェアが効果的に利用できるものだけを選択して、それらのユースケースをリストアップして、箇条書きで作成してください。
- それぞれのユースケースには、以下の項目を含めてください。
  - ユースケースID
  - 名称
  - ユースケースの詳細な説明
  - ユースケースとして抽出した詳細な選定の理由
  - 利用できる既存のアプリケーション。もしくは、SaaSサービス。独自に開発しなくても良いもの。
  - 独自に開発した方がメリットが大きい場合には、その具体的かつ説得力のある詳細な理由の説明
  - 独自に開発した方がメリットが大きい場合には、ビジネス上の価値について1-5でランク付け。区分：Low=1–2 / Med=3 / High=4–5
- 必要な情報が不足している場合は、その項目には"N/A"と入力してください。

# ガイドライン
- はじめに行う作業の概要を、3～7項目程度のコンセプチュアルなチェックリストとして簡潔に示してください。
- もし作業を進めるための情報が不足してたら、ユーザーに質問をしてください。
```

> [!NOTE]
> 作成結果は、GitHubのRepositryにドキュメントとして保存しておくことをお勧めします。


作業の着手する優先度の参考情報を作成します。

```text
独自開発の有効性と、ビジネス価値ランクを中心に分析して、独自開発に取り組むべきユースケースを、マトリックス化して、ロードマップを作成してください。
```

### Step.2.2 ユースケース作成

ユースケースを1つだけ選択して、そのユースケースの詳細を作成します。
step.2.1でのチャットを継続するのがおススメです。

ここから先の全てのチャットの出力した情報をユースケースの単位でMarkdownにします。Microsoft 365 Copilot Chatを使っている場合は、**Pageに編集**で、Loopのファイルとして保存するのが便利です。

```text
# タスク
- 対象のユースケース（JBO-UC-001: 電子申請・電子決裁）について、ソフトウェアとして独自に実装するための、できる限り詳細かつ具体的で深い、ユースケースを作成してください。
- 作成するユースケースは、添付の「ユースケースの項目」のドキュメント内のフォーマット・設計ルールに従い、対象のユースケースのみを出力してください。

# ガイドライン
- すべての項目を必ず記載し、記載順も上記に従ってください。
- 項目が生成できない場合は、その理由を簡潔に明記し、出力フォーマットは維持してください。

## ユースケースの項目

### 1. **ユースケース名 (Use Case Name)**
- 簡潔で明確な名前（例：「商品をカートに追加する」）

### 2. **ユースケースID (Use Case ID)**
- 一意な識別子（例：UC-001）

### 3. **目的 (Goal / Description)**
- ユーザーがこのユースケースを通じて達成したい目的

### 4. **アクター (Primary Actor)**
- このユースケースを実行する主体（例：顧客、管理者、外部システム）

### 5. **ステークホルダーと関心事 (Stakeholders and Interests)**
- 各ステークホルダーとその関心事（例：顧客は迅速なレスポンスを期待）

### 6. **前提条件 (Preconditions)**
- ユースケースが開始される前に満たされているべき条件

### 7. **終了条件 (Postconditions)**
- 成功時と失敗時のシステムの状態

### 8. **トリガー (Trigger)**
- ユースケースが開始されるきっかけ（例：ユーザーが「購入」ボタンを押す）

### 9. **基本フロー (Main Success Scenario / Basic Flow)**
- 正常系のステップバイステップの流れ

### 10. **代替フロー (Alternative Flows)**
- 条件分岐や例外処理の流れ（例：在庫切れ時の処理）

### 11. **例外フロー (Exception Flows)**
- エラーや障害が発生した場合の処理

### 12. **ビジネスルール (Business Rules)**
- このユースケースに関連する業務ルールや制約

### 13. **UI/UX要件 (Optional)**
- 関連する画面やインタラクションの概要（ワイヤーフレームなど）

### 14. **非機能要件 (Non-functional Requirements)**
- パフォーマンス、セキュリティ、可用性などの要件

### 15. **関連ユースケース (Related Use Cases)**
- このユースケースと関係する他のユースケース

### 16. **メモ・補足情報 (Notes and Issues)**
- その他の注意点、未解決の課題など

# ガイドライン
- はじめに行う作業の概要を、3～7項目程度のコンセプチュアルなチェックリストとして簡潔に示してください。
```

## Step 3. マイクロサービスアプリケーション定義書の作成

ユースケースの情報があれば、画面やサービス、データなど各種のモデリングが可能です。
ここからはマイクロサステ進め方をある程度踏襲して、具体的な関連情報を文章化していきます。

このStep.3の各ステップで作成した情報は、最終的に1つのMarkdownのドキュメントにまとめておくことをお勧めします。それが、個々のAPI実装の定義書になるからです。
Microsoft 365 Copiot Chatを使っている場合は、**Pageに編集**で、Loopのファイルとして保存するのが便利です。Step 3.1.が出力されたら、Pageを一つ作成。その後は、同じPageのファイルに**追加**していきます。

### Step 3.1. ドメイン分析の実施

まず業務上のドメイン分析を行います。

```text
添付のファイルはユースケースです。
このユースケースを深くかつ慎重に分析・解析をして、ビジネス機能のドメインモデリングをして、業務ドメインをリストアップしてください。

# タスク
## ドメインモデリング
  - ユースケースを分析し、**ドメイン駆動設計（DDD）の観点から境界づけられたコンテキスト（Bounded Context）**を特定します。
  - 各ユースケースが属するビジネスドメインを明確にし、機能の自然な分割線を見つけます。

# ドメインモデリングの項目

### 1. **ドメインID (Use Case ID)**
- 一意な識別子（例：UC-001）

### 2. **ユビキタス言語（Ubiquitous Language）**
- ドメイン専門家と開発者が共通で使う言葉の定義集。
- モデルの一貫性とコミュニケーションの正確性を担保。

### 3. **エンティティ（Entity）**
- 識別子を持ち、ライフサイクルを通じて一意に識別されるオブジェクト。
- 例：`Order`, `Customer`, `Product` など。

### 4. **値オブジェクト（Value Object）**
- 識別子を持たず、属性の集合として扱われるオブジェクト。
- 例：`Address`, `Money`, `DateRange` など。

### 5. **集約（Aggregate）と集約ルート（Aggregate Root）**
- 一貫性を保つためのオブジェクトの集合と、その入口となるルート。
- 例：`Order` が `OrderLine` を含む集約。

### 6. **ドメインサービス（Domain Service）**
- エンティティや値オブジェクトに属さない、ビジネスロジックを表現するサービス。
- 例：`PaymentProcessingService`

### 7. **リポジトリ（Repository）**
- 集約の永続化と再構築を担当するインターフェース。
- 例：`OrderRepository`, `CustomerRepository`

### 8. **ファクトリ（Factory）**
- 複雑なオブジェクトの生成を担当するコンポーネント。
- 例：`OrderFactory`

### 9. **バウンデッドコンテキスト（Bounded Context）**
- モデルが有効に機能する境界。コンテキストごとにユビキタス言語やモデルが異なる。
- 例：`Sales`, `Inventory`, `Billing` などのコンテキスト。

### 10. **コンテキストマップ（Context Map）**
- バウンデッドコンテキスト間の関係を示す図や記述。
- 例：`Customer` は `CRM` コンテキストでは詳細情報を持ち、`Order` コンテキストでは参照のみ。

### 11. **ドメインイベント（Domain Event）**
- ドメイン内で発生した意味のある出来事。
- 例：`OrderPlaced`, `PaymentConfirmed`

## 12.メモ
 - 特記事項など

# ガイドライン
- はじめに、実行する主な作業のチェックリスト（3-7項目、概念レベル）を簡潔に示してください。その後、以下の手順に従って進めてください。
- 作業後には、出力内容が要件に合致しているか1-2行で自己検証し、不備があれば修正を行ってください。
```

### Step 3.2. サービスの候補の抽出

この直前で行ったチャットに続けて、リストアップしたドメインやエンティティの

```text
このユースケースにおいて、リストアップされた、全ての業務ドメインを深くかつ慎重に分析・解析をして、マイクロサービスとして実装するためのサービスの候補をリストアップしてください。{サービス候補一覧}のフォーマットに従ってください。

# タスク
- 各ユースケースまたはユースケース群を、**単一責任の原則（SRP）**に基づいてサービス候補に分割します。
- サービス候補は、独立してデプロイ可能で、他サービスと疎結合であることが理想です。

# サービス候補一覧

### {サービス候補ID}: {サービス候補名}

**ステータス**: 候補/承認/設計中/実装中/保留/統合検討/却下/廃止予定  
**BC**: {境界づけられたコンテキスト} / **サブドメイン**: コア/支援/汎用  
**対応UC**: {UC-ID, UC-ID,...}  
**一次責務（SRP）**:  
- {責務1}
- {責務2}

**非責務（明示）**: {例: 決済代行は担当しない}

#### ドメインモデル
- **アグリゲート/エンティティ**: {例: Order, OrderLine}
- **発行イベント**: {例: OrderPlaced, OrderCancelled}
- **購読イベント**: {例: PaymentCaptured}
- **不変条件/制約**: {例: 合計金額 ≥ 0}

#### データ所有・ストレージ
- **所有データ境界**: {箇条書き}
- **データ分類/機密度**: {公開/社内/機微/機密、APPI 対応?}
- **読み書き特性**: {例: R:W=4:1, 時系列追記型}
- **ストレージ選択/理由**: {例: Postgres（トランザクション）}
- **保持/アーカイブ**: {例: 7年、PIIは36ヶ月で削除}
- **RPO/RTO**: {例: 5分/30分}

#### インターフェース/契約
- **同期API**: {主要エンドポイント}
- **非同期契約**: {トピック/スキーマ}
- **契約版管理/互換方針**: {後方/前方互換}
- **Idempotency/整合性**: {戦略}

#### サービス間インタラクション
- **下流依存**: {例: PaymentSvc, InventorySvc}
- **上流依存**: {例: ShippingSvc}
- **通信方式（理由）**: {同期/非同期/混在 + 理由}
- **コンテキストマップ関係**: {例: Conformist}

#### 非機能
- **SLO/SLI**: {例: 99.95%, p95 200ms}
- **スケール特性**: {例: 2k rps, 年末 5x}
- **耐障害性**: {リトライ/タイムアウト/CB}
- **可観測性**: {メトリクス/ログ/トレース}

#### セキュリティ/コンプライアンス
- **認証/認可**: {例: OIDC + RBAC}
- **データ保護**: {At-rest/ In-transit 暗号化}
- **監査/規制**: {APPI/PCI 等}

#### 実装/デプロイ/運用
- **技術スタック**: {言語/ランタイム}
- **デプロイ単位**: {K8s/Serverless 等}
- **リージョン/DR**: {例: APNE1 主, APNE2 DR}
- **リリース戦略**: {Blue/Green/Canary}
- **Runbook**: {URL}

#### 意思決定
- **ビジネス価値**: {定性的/定量的}
- **リスク/不確実性**: {列挙}
- **規模見積**: {人週/リードタイム}
- **優先度スコア（式/値）**: {例: 価値×2 + 緊急度 + 依存解消×1.5 = 8.5}
- **代替案 / Split-Merge**: {記述}

#### 決定ログ & 未決
- **重要な決定**: {ADR リンク}
- **仮説/前提**: {列挙}
- **未解決事項（オーナー/期日）**: {列挙}
- **次アクション**: {列挙}

# ガイドライン
- はじめに、実行する主な作業のチェックリスト（3-7項目、概念レベル）を簡潔に示してください。その後、以下の手順に従って進めてください。
- 作業後には、出力内容が要件に合致しているか1-2行で自己検証し、不備があれば修正を行ってください。
```

### Step 3.3. データモデル作成

データモデルの作成は大変便利です。ここまでの業務要件の流れから抽出することで、プロトタイプとして利用者が利用イメージが湧きやすくなり自分事として捉えやすくなります。また、既存のデータソースとの接続が難しい場合など、それに引きずられること無く、アプリケーションの開発に入っていけます。

```text
このユースケースで使用する、全てのエンティティを深くかつ慎重に分析・解析をして、リストアップしてください。

# タスク
- 各サービスが独自のデータストアを持つように設計し、データの所有権を明確にします。
- 整合性は最終的整合性（Eventual Consistency）を前提に、イベントソーシングやCQRSなどのパターンを検討します。

# ガイドライン
- はじめに、実行する主な作業のチェックリスト（3-7項目、概念レベル）を簡潔に示してください。その後、以下の手順に従って進めてください。
- 作業後には、出力内容が要件に合致しているか1-2行で自己検証し、不備があれば修正を行ってください。
```

**サンプルデータ**を作成します。これ、とても大事です!

```text
このユースケースで使用する、全てのエンティティの日本語のサンプルデータをjson形式で10件ずつ作成をして表示してください。
```

### Step 3.4. 画面遷移図の作成

画面の作成に入ります。

```text
このユースケースにおいて、ユーザーが利用する画面の一覧と画面遷移図を、深くかつ慎重に分析・解析をして、作成してください。

## 出力形式

### 1. 画面一覧（Screen List）
以下の形式で画面をリストアップしてください。。次の情報を含めてください：
- screen_id: 画面ごとの一意のID
- screen_name: 画面名
- description: 画面の簡単な説明
- function_type: 主要機能（例：入力フォーム、承認画面、完了画面など）

### 2. 画面遷移図（Screen Transition Diagram）
画面遷移図は、テキストベースで画面IDまたは画面名をノードとして表現し、矢印（->）で遷移関係を記述してください。
#### 例：
[申請入力画面] -> [確認画面] -> [完了画面]
                       ↓
                [差し戻し画面]
または上記と同様のテキスト記述で明確にしてください。

### 3. エラーハンドリング
画面の特定や遷移が曖昧または資料から判断できない場合は、その旨を備考または注意事項として明記してください。

出力の最後に主要な成果物（画面一覧・遷移図）とエラーハンドリング内容を簡潔に検証し、問題がなければ次に進むか、必要なら修正を行ってください。

# ガイドライン
- はじめに行う作業の概要を、3～7項目程度のコンセプチュアルなチェックリストとして簡潔に示してください。
- 作業後には、出力内容が要件に合致しているか1-2行で自己検証し、不備があれば修正を行ってください。
```

### Step 3.5. マッピング表の作成

このドキュメントを最終的に作りたかったのです!
画面とサービスとデータ。それぞれに識別のためのIDを付与して、今後、個々に仕様書として作成するドキュメントを紐づけます。

このマッピング表だけは、見直し改善Promptを実施しても良いかと思います。

[見直し改善Prompt](/高度なテクニック/README.md#4-promptを自己改善してもらう)

```text
このユースケースを、マイクロサービスアーキテクチャで構築するアプリケーションの、
画面 → **画面内機能 → 画面内処理 or API呼び出し → APIが管理するデータ
のマッピングを、深くかつ慎重に分析・解析をして、わかりやすい表形式で作成してください。
マイクロサービスアーキテクチャの原則を必ず守って設計を行ってください。

## 要件：

- 各画面ごとに、以下を整理すること
  - 画面ID
  - 画面名
  - 画面内の主要な機能（例：検索、登録、削除など）
  - その機能が「画面内処理」か「API呼び出し」かを明示
  - API呼び出しの場合は、API ID、API名、エンドポイント、HTTPメソッド、主要パラメータを記載
  - APIが管理するデータ（SoT）を明記
- 最後に、APIサービスと管理データの責務マッピング表も追加してください

さらに、可能であれば以下も含めてください：

- 画面とAPIの関係を俯瞰できるハイレベルマッピング表
- 設計のベストプラクティスや注意点（冪等性、競合制御、バルク操作など）

# ガイドライン
- はじめに行う作業の概要を、3～7項目程度のコンセプチュアルなチェックリストとして簡潔に示してください。
- 作業後には、出力内容が要件に合致しているか1-2行で自己検証し、不備があれば修正を行ってください。
```

作業手順の中で**機能やAPI**の概要を作成している点をお忘れなく。

> [!NOTE]
> 作成結果は、GitHubのRepositryにドキュメントとして保存しておくことをお勧めします。


## Step 4. 生成AIに最適化した各コンポーネントプロンプトの作成

> [!NOTE]
> これでもある程度は動きますが。もっとPromptとして最適化できると思います...

Step 3で作成したユースケースの情報をもとに、生成AIに最適化したプロンプトを作成します。

Step 3.で作成したファイルを添付して、一つずつ作成していきます。

> [!NOTE]
> Microsoft 365 CopilotでPageを作成すると、それは自分のLoopのMy Workspaceに保存されます。別のチャットの中で、**作業コンテンツ**として指定することができます。作業コンテンツの検索結果に反映されるまで数分かかる場合があります。


### Step 4.1. 画面の作成

画面定義書は、既存のドキュメントを強く意識している「人」が理解しやすいであろう構造化情報として作成されています。

画面の一覧から、1つを選んで、その画面の指示書を作成します。
画面の一覧にSPAなどに適した**ポータル**的なものが無かったら、複数画面を切り替えて、画面とサービスの追加・削除も容易になりそうなポータル画面を別途作成するのも良いかと思います。

```text
# 目的
ソフトウェアでの実装のための画面の指示書を作成します。

# タスク
- 作成の対象は、{画面名}です。
- 作成する内容は、{指示書のガイドライン}をチェックリストとしてだけ**必ず**遵守して、深く分析・解釈してください。書式は{指示書のガイドライン}とは別でよいです。
- 作成する例として、{最適化された指示書の例}も必ず参考にしてください。
- 先に作成した{日本語のサンプルデータ}の全てのデータを、データとして必ず追記してください。データが入っている事で、画面の作成後に、即座に利用することができるようにしてください。
---

# 指示書のガイドライン

## 1. 全体評価

* プロンプトの目的とゴールの明確性を評価する。
* 受け入れ基準がテスト可能であることを示す。
* 機能追加の段階性（基礎 → 拡張 → 制約）を分析する。
* 曖昧さを取り除き、非機能要件・公平性・UXを補強する。

## 2. 仕様の厳密化

### コア機能

* **入力**：ユーザー単語リスト、任意のグリッドサイズ（デフォルト12×12、範囲6～20）。
* **配置**：8方向（N, NE, E, SE, S, SW, W, NW）、前後両向き。配置失敗時は一定回数リトライ。未使用セルはA–Zランダム。
* **検出**：マウス（クリック→ドラッグ→離す）、タッチ（長押し→スワイプ→離す）。直線一致で「発見」状態。
* **完了**：全語発見でタイマー停止、「新規パズル作成」ボタンを提示。

### タイマー & リーダーボード

* **開始**：生成直後に自動スタート。
* **停止**：最後の語発見時に停止。
* **フォーマット**：`MM:SS.mmm`（ms精度、表示は四捨五入）。
* **記録項目**：名前、時間、語数、サイズ。
* **ソート**：昇降順切替可能（時間／語数／名前）。同率時は**時間→語数→名前**でタイブレーク、安定ソート必須。
* **公平性**：サイズ×語数ごとにランキングを分離。

### 入力制約 & エラー

* **単語長 ≤ min(行, 列)**。違反時は「語はサイズ以下にしてください」と即時エラー。
* **文字種**：A–Z（大文字小文字非区別、空白/ハイフン除去）。
* **重複語**：一意化または警告のいずれかを仕様化。
* **最大語数**：例 5–20、超過や配置不能時は「語数を減らすかサイズを増やしてください」。

### データモデル & アルゴリズム

* **モデル**：`Grid`, `Word{text, path}`, `Score{name, timeMs, wordCount, gridSize}`。
* **配置**：ランダム起点＋方向、失敗時リトライ（上限=面積×2）。
* **乱数**：毎回変化（将来拡張でシード固定可）。
* **性能目安**：12×12で10語 → 100ms以内に生成。

### UX / A11y

* **キーボード操作**：矢印移動＋Enterで選択、Escで解除。
* **色覚対応**：色＋下線／太字併用。
* **スクリーンリーダー**：`aria-live`で進捗を読み上げ。
* **フォーカス管理**：タブ順序保証。

### セキュリティ & プライバシー

* 名前入力はサニタイズ、最大長24文字、制御文字禁止。
* 保存範囲はローカルのみ。共有や送信は行わない。

### 非機能要件

* 反応速度：検出レスポンス16ms以内。
* 永続化：localStorageに100件まで履歴保存。
* オフライン：PWA拡張可能。

### アンチ要件（除外範囲）

* ヒント機能、マルチプレイ、サーバ同期、厳格チート検出は含めない。

## 3. 曖昧さと解決

* 「斜め」＝NE／NW／SE／SW の4方向と明記。
* 「ドラッグ」＝連続セル追従操作と定義。
* タイマーは一時停止なし。
* 同率スコアは必ず単一順位を決定。

## 4. 受け入れ基準例（Gherkin風）

* **語長境界**：10×10で長さ10 → 成功。長さ11 → エラー表示。
* **操作**：連続セルドラッグで一致 → 発見状態＋バンクにチェック。
* **タイマー**：生成直後に`00:00.000`から加算開始、全語発見で停止。
* **ランキング**：時間昇順、同率は語数→名前順。

## 5. リスクとトレードオフ

* 語数過多×小サイズ → 自動拡大提案。
* 色のみ強調はNG → 装飾併用で補正。
* ローカル保存はチート耐性低 → 許容範囲と明示。

## 6. 拡張余地

* 難易度プリセット、カテゴリ別語リスト、辞書検証、シード固定、PWA対応、共有ランキングAPI。

## 7. 最終チェックリスト

* ゴール／完了条件／操作が一読で明確か？
* 8方向＋逆方向が定義されているか？
* 境界値とエラーメッセージが明文化されているか？
* タイマー仕様（開始・停止・丸め）が厳密か？
* リーダーボードが公平で、ソート＋同率処理が定義されているか？
* A11y・非機能要件が網羅されているか？
* スコープ外が宣言されているか？

---

# 最適化された指示書の例
- Please create a word search game. The game should take in a set of words from the user, then create a word search puzzle containing those words, as well as a word bank listing the words. Words in the puzzle can be horizontal, vertical, diagonal, forwards, and backwards, and are "found" when the user clicks and drags their mouse across them. Once all words are found, give the user the option to create a new puzzle.
- Please add a leaderboard and a timer to the game. The timer should start when the user generates a new puzzle, then stop when all words are found. The user should then be able to enter their name, and their name, time, and the number of words in their puzzle should be displayed on the leaderboard. The leaderboard should be sortable in ascending and descending order by each of the three categories.
- Please prevent users from entering words longer than the number of rows or columns in the puzzle. Additionally, add an option to change the size of a puzzle. If the user tries to enter a word that's longer than the current size of the puzzle, display an error message telling them that provided words must be less than or equal to the size of the puzzle.

# ガイドライン
- はじめに行う作業の概要を、3～7項目程度のコンセプチュアルなチェックリストとして簡潔に示してください。
```

参考:
https://docs.github.com/en/copilot/tutorials/easy-apps-with-spark

### Step.4.2. マイクロサービスの作成

サービスの候補から、1つを選んで、マイクロサービス定義書に準拠したドキュメントを作成します。

Prompt:

```text
{KPI-01-DEF:KPI定義参照}を対象として、{マイクロサービス定義書}に準拠したマイクロサービスのドキュメントを作成してください。

## マイクロサービス定義書

### 1. **サービスメタ情報**
- **サービス名／短縮名**：例）Template Service（TPL）  
- **概要（One-liner）**：何を「いつ・誰に・なぜ」提供するか。  
- **責務（Do）／非責務（Don’t）**：境界の明示。承認ルーティング**実行**は非責務 等。  
- **利害関係者・主要ペルソナ**（任意）：管理者、部門管理者、申請者、監査。

### 2. **ビジネス能力・コンテキスト**
- **対象ドメインとユースケースの対応表**：FR-002-01 下位要件とのトレーサビリティ。  
- **ライフサイクル**：ドラフト→レビュー→公開→廃止（状態と遷移イベント）。

### 3. **公開インターフェース（同期）**
- **API スタイル**：REST（JSON/UTF‑8）（※GraphQL 等の場合は理由）。  
- **リソース一覧（概要）**：`/templates`、`/types`、`/fields`、`/diff`、`/preview` …（**動詞ではなく名詞**で統一）。  
- **操作粒度**：作成／取得／検索（フィルタ・ソート・ページング規約）／公開／廃止／差分取得／プレビュー。  
- **冪等性**：`Idempotency-Key` の扱い、重複作成の基準。  
- **エラー語彙（概要）**：`TPL-VAL-001 必須欠落`、`TPL-STATE-001 状態不正` などの**コード体系と責務境界**。  
> ※後でコード生成するため、ここには**OpenAPI の骨子**（パス・ステータス・代表スキーマ名）だけを置く。

### 4. **公開インターフェース（非同期）**
- **ドメインイベント（発行）**：`TEMPLATE.PUBLISHED`、`TEMPLATE.RETIRED` など。  
  - 目的、発火条件、**最小ペイロード項目**（識別子、版、適用開始、破壊的変更フラグ 等）。  
- **サブスクライブ（受信）**：MDM 更新、承認ルール変更、インボイス検証結果 等。  
- **配信保証**：少なくとも 1 回／順序性／再送ポリシー（概念レベル）。  
> ※後でコード生成するため、ここには**AsyncAPI の骨子**（チャンネル名・メッセージ名・キー属性）だけを置く。

### 5. **データ所有・モデル（概念）**
- **主エンティティと所有者**：Template（本サービス所有）、RequestType（同）、AttachmentPolicy（同） 等。  
- **整合性・一意性ルール**：同一 `typeId` で同時点に有効な版は1つ、破壊的変更は新規版 等。  
- **データ分類／個人情報**：PII/非PII、電帳法検索キーの取り扱い。  
- **マルチテナンシ／スコープ**：全社／部門／ロール／属性（可視性の粒度）。

### 6. **セキュリティ・権限**
- **認証**：OIDC/SSO（MFA 前提）。  
- **認可**：RBAC/ABAC（属性例：部門 ID、役職、委任期間）。  
- **暗号化**：転送中 TLS、保存時 KMS、添付はオブジェクトストレージのサーバサイド暗号化。  
- **監査**：操作（作成／編集／公開／廃止／ロールバック）の**不可改ざん記録**（何を・誰が・いつ・どこから）。

### 7. **外部依存・統合**
- **依存先と契約**：  
  - MDM/HR（組織・職位・権限・委任）  
  - 承認エンジン（RuleSet 参照のみ）  
  - 電帳法対応ストレージ／タイムスタンプ  
  - インボイス検証 API  
  - ERP/会計/契約台帳/DWH  
- **フォールバック戦略**：外部検証障害時は暫定許可→**後続検証キュー**、時間切れ時のポリシー。

### 8. **状態遷移・ビジネスルール**
- **状態機械（概念図）**：Draft → InReview → Published → Retired（RollBack 可否）。  
- **条件分岐の原則**：金額・カテゴリ・海外判定等に基づく動的表示／必須化の**安全側フォールバック**。  
- **公開可否ゲート**：電帳法検索キーが欠落するテンプレは公開不可 等。

### 9. **非機能・SLO（概念）**
- **可用性／パフォーマンス目安**：例）p50/p95 レイテンシ、同時編集想定、イベント伝播遅延上限。  
- **スケーラビリティ**：読み主体（一覧・プレビュー）最適化、書き（公開）時の直列化。  
- **運用監視**：メトリクス（差戻し率、滞留時間、公開後エラー率）、トレース、構成変更監視。  

### 10. **バージョニング／互換性**
- **API 版付け**：`/api/v1/...` の原則、後方互換の維持と**廃止告知期間**。  
- **テンプレ版と適用範囲**：新規起票には最新版、既存案件は旧版維持／ドラフトの自動マイグレーション方針（案内のみ、強制なし）。  
- **イベント版付け**：メッセージの `schemaVersion` と互換規約。

### 11. **エラー・レート制御・再試行**
- **エラー体系（概要）**：`TPL-VAL-xxx`（検証）、`TPL-STATE-xxx`（状態）、`TPL-API-xxx`（外部障害）など**命名規約**。  
- **レート制限**：管理操作（公開・廃止）は保守的、読み取りは緩め。  
- **再試行ポリシー**：クライアント／サーバの責務分界、**冪等性キー**利用時の再送許容。

### 12. **設定・フラグ**
- **機能フラグ**：ローカライズ有効化、OCR 有効化、破壊的変更ガード。  
- **構成キー**：外部 API タイムアウト、最大添付サイズ、OCR リトライ回数（値はここでは**未記載**）。

### 13. **移行・初期データ（任意）**
- **初期テンプレの投入計画**、旧システムからの**読み替え原則**、識別子のマッピング方針。

### 14. **テスト指針（概念）**
- **契約テスト**（Provider/Consumer）、**状態遷移テスト**、**ローカライズの可用性テスト**、**監査改ざん検知テスト**。  
- **テストデータ原則**：サンプルテンプレと最小必須証憑。

### 15. **運用・リリース（概念）**
- **デプロイ戦略**：ローリング／カナリア（公開・廃止の**時間指定**に対応）。  
- **ロールバック**：API とデータの整合を保つための**版単位**ロールバック手順（概念）。  
- **通知・チェンジマネジメント**：リリースノート、影響分析、対象ユーザへの配布ポリシー。

### 16. **リスク・オープン課題**
- 例：外部検証 API の SLA 未定義、MDM の属性欠落、部門差分の継承衝突 等。

## 17. **画面・操作・API・イベント マッピング**
- **目的**：UI（画面）とマイクロサービスの責務を明確化し、疎結合な設計を担保する。  
- **マッピング表**：
- **原則**：  
  - 1画面＝1主要サービス（UIロジックは集約しない）  
  - 複数サービスを呼ぶ場合は**BFF（Backend for Frontend）**でオーケストレーション  
  - 画面IDはFRDやUI設計書とトレーサブルに  

### 付録 A（コード生成用の“骨子”を添付）
- **OpenAPI（スケルトン）**：パス・メソッド・代表スキーマ名のみ。  
- **AsyncAPI（スケルトン）**：チャンネル名・イベント名・キー属性のみ。  
- **JSON Schema（概念版）**：`Template`, `FieldDefinition`, `AttachmentPolicy` の最低限属性。  
- **用語集／語彙**：ラベル、状態、エラーコードの辞書。

# ガイドライン
- はじめに行う作業の概要を、3～7項目程度のコンセプチュアルなチェックリストとして簡潔に示してください。
```
# アプリケーション設計

ソフトウェアエンジニアがアプリケーション開発に着手するための入力情報となりえるドキュメントを作成します。

# ツール
GitHub CopilotはSoftware Engineeringについては比較的良いOutputを出してくれます。
ただし、GitHub CopilotのAgentは、デフォルトでFirewallの設定があり、MCP経由でないと外部の情報を参照ができません。
その点では、Microsoft 365 CopilotのGPT-5でも良いかもしれません。

GitHub Copilotには複数のAgentがあります。ご自分の好みのものを選択してください。

https://docs.github.com/ja/copilot/get-started/features

- GitHub Copilot Agent Mode
Visual Studio XなどのIDEに組み込まれたCopilotです。モデルを複数から選択できるメリットがあります。

- GitHub Copilot Coding Agent
Coding Agentの場合はDeep Reserch系の動作をすることもあって、若干時間を要しますが以下のメリットもあります。

  - GitHubのIssueとしてトラックできる
  - Issue発効後は、手元のPCなどで別作業がしやすい
  - バッチ的に複数のファイル作成がやりやすい

> [!NOTE]
> 作成結果は、GitHubのRepositryにドキュメントとして保存しておくことをお勧めします。


## Step.1 ユースケース作成

要求定義から、ユースケースを作成します。

[要求定義の作成](./Documentation.md)

要求定義のドキュメントは、**Markdown**の形式にして、`/docs`フォルダに保存します。

### Step.1.1 ユースケース一覧作成 

Step.1 で作成したLoopのファイルを**作業コンテンツ** (添付ファイル)として追加します。

```text
# 役割
あなたは、世界最高峰のソフトウェア製品を数多く成功に導いてきたプリンシパル・プロダクトマネージャーです。あなたの役割は、複雑な要求定義ドキュメントを精緻に分析し、ビジネス目標とユーザーのニーズに整合した、明確で実行可能なユースケースを抽出することです。構造的思考、ドメイン知識、ユーザー中心設計の原則を駆使し、ユースケースの網羅性、明確性、追跡可能性を確保します。

# タスク
- 添付ドキュメントには、ある企業の事業課題とその解決策が含まれています。
  - docs/<要求定義>.md

- 解決策の実現方法を慎重に検討してください。
- 実現の手段として、ソフトウェアが効果的に利用できるものと、そうでないものがあります。
- ソフトウェアが効果的に利用できるものだけを選択して、それらのユースケースをリストアップして、箇条書きで作成してください。
- それぞれのユースケースには、以下の項目を含めてください。
  - ユースケースID
  - 名称
  - ユースケースの詳細な説明
  - ユースケースとして抽出した詳細な選定の理由
  - 利用できる既存のアプリケーション。もしくは、SaaSサービス。独自に開発しなくても良いもの。
  - 独自に開発した方がメリットが大きい場合には、その具体的かつ説得力のある詳細な理由の説明
  - 独自に開発した方がメリットが大きい場合には、ビジネス上の価値について1-5でランク付け。区分：Low=1–2 / Med=3 / High=4–5
- 必要な情報が不足している場合は、その項目には"N/A"と入力してください。
- 独自開発に取り組むべきユースケースを、独自開発をする有効性のランクと、ビジネス価値ランクを中心に分析して、マトリックスを作成してください。
ロードマップもMermaid記法で作成してください。


# ファイルの作成場所
作成結果は、以下のファイルに保存してください。
- /docs/usecase/usecase-list.md
```

### Step.1.2 ユースケース作成

ユースケース一覧を参考にして、全てのユースケースについて、ユースケースを作成します。

```text
# 役割
あなたは、世界最高峰のソフトウェア製品を数多く成功に導いてきたプリンシパル・プロダクトマネージャーです。あなたの役割は、複雑な要求定義ドキュメントを精緻に分析し、ビジネス目標とユーザーのニーズに整合した、明確で実行可能なユースケースを抽出することです。構造的思考、ドメイン知識、ユーザー中心設計の原則を駆使し、ユースケースの網羅性、明確性、追跡可能性を確保します。

# タスク
- ユースケースの一覧を参考にして全てのユースケースについて、ソフトウェアとして独自に実装するための、できる限り詳細かつ具体的で深い、ユースケースを作成してください。
- 作成するユースケースは、添付の「ユースケースの項目」のドキュメント内のフォーマット・設計ルールに従い、対象のユースケースのみを出力してください。

## 参考ドキュメント
  - docs/<要求定義>.md
  - docs/usecase/usecase-list.md

# 作成ファイル
  - docs/usecase/{ユースケースID}/usecase-description.md
    - {ユースケースID}は、各ユースケースのIDを設定する

# ガイドライン
- すべての項目を必ず記載し、記載順も上記に従ってください。
- 項目が生成できない場合は、その理由を簡潔に明記し、出力フォーマットは維持してください。

## ユースケースの項目

### 1. **ユースケース名 (Use Case Name)**
- 簡潔で明確な名前（例：「商品をカートに追加する」）

### 2. **ユースケースID (Use Case ID)**
- 一意な識別子（例：UC-001）

### 3. **目的 (Goal / Description)**
- ユーザーがこのユースケースを通じて達成したい目的

### 4. **アクター (Primary Actor)**
- このユースケースを実行する主体（例：顧客、管理者、外部システム）

### 5. **ステークホルダーと関心事 (Stakeholders and Interests)**
- 各ステークホルダーとその関心事（例：顧客は迅速なレスポンスを期待）

### 6. **前提条件 (Preconditions)**
- ユースケースが開始される前に満たされているべき条件

### 7. **終了条件 (Postconditions)**
- 成功時と失敗時のシステムの状態

### 8. **トリガー (Trigger)**
- ユースケースが開始されるきっかけ（例：ユーザーが「購入」ボタンを押す）

### 9. **基本フロー (Main Success Scenario / Basic Flow)**
- 正常系のステップバイステップの流れ

### 10. **代替フロー (Alternative Flows)**
- 条件分岐や例外処理の流れ（例：在庫切れ時の処理）

### 11. **例外フロー (Exception Flows)**
- エラーや障害が発生した場合の処理

### 12. **ビジネスルール (Business Rules)**
- このユースケースに関連する業務ルールや制約

### 13. **UI/UX要件 (Optional)**
- 関連する画面やインタラクションの概要（ワイヤーフレームなど）

### 14. **非機能要件 (Non-functional Requirements)**
- パフォーマンス、セキュリティ、可用性などの要件

### 15. **関連ユースケース (Related Use Cases)**
- このユースケースと関係する他のユースケース

### 16. **メモ・補足情報 (Notes and Issues)**
- その他の注意点、未解決の課題など
```

## Step.2. マイクロサービスアプリケーション定義書の作成

ユースケースの情報があれば、画面やサービス、データなど各種のモデリングが可能です。
ここからはマイクロサービスでの設計の進め方をある程度踏襲して、具体的な関連情報を文章化していきます。

### Step.2.1. ドメイン分析の実施

ここでは作成されたユースケースから、1つだけ選択して、業務上のドメイン分析を行います。

```text
# 役割
あなたは、マイクロサービスアーキテクチャに関する高度な専門知識と実務経験を持つソフトウェアアーキテクトです。
以下のような視点とスキルを持ち、技術的な意思決定を論理的かつ実践的に行うことが求められます：

- **システム全体の構造設計**：ドメイン駆動設計（DDD）やClean Architectureの原則に基づき、サービスの責務分離と依存関係の最適化を行う。
- **スケーラビリティと可用性の確保**：クラウドネイティブな設計（例：Kubernetes、サービスメッシュ）を活用し、システムの拡張性と耐障害性を担保する。
- **データ管理戦略の策定**：マイクロサービス間のデータ整合性、分散トランザクション、イベント駆動アーキテクチャ（EDA）などを適切に設計する。
- **セキュリティと運用性の考慮**：認証・認可（OAuth2, JWT）、監視（Observability）、CI/CDパイプラインの設計など、運用フェーズを見据えた設計を行う。
- **技術選定とトレードオフの判断**：技術スタックの選定において、パフォーマンス、保守性、チームのスキルセットなどを考慮し、合理的な判断を下す。

あなたの役割は、これらの観点を踏まえて、与えられた目的に対して最適なアーキテクチャ設計や技術的提案を行うことです。

# 目的

このユースケースを深くかつ慎重に分析・解析をして、ビジネス機能のドメインモデリングをして、業務ドメインをリストアップしてください。

## 参考ドキュメント
  - docs/usecase/{ユースケースID}/usecase-description.md

# 作成ファイル
  - docs/usecase/{ユースケースID}/domain-analytics.md

# タスク
## ドメインモデリング
  - ユースケースを分析し、**ドメイン駆動設計（DDD）の観点から境界づけられたコンテキスト（Bounded Context）**を特定します。
  - 各ユースケースが属するビジネスドメインを明確にし、機能の自然な分割線を見つけます。

# ドメインモデリングの項目

### 1. **ドメインID (Use Case ID)**
- 一意な識別子（例：UC-001）

### 2. **ユビキタス言語（Ubiquitous Language）**
- ドメイン専門家と開発者が共通で使う言葉の定義集。
- モデルの一貫性とコミュニケーションの正確性を担保。

### 3. **エンティティ（Entity）**
- 識別子を持ち、ライフサイクルを通じて一意に識別されるオブジェクト。
- 例：`Order`, `Customer`, `Product` など。

### 4. **値オブジェクト（Value Object）**
- 識別子を持たず、属性の集合として扱われるオブジェクト。
- 例：`Address`, `Money`, `DateRange` など。

### 5. **集約（Aggregate）と集約ルート（Aggregate Root）**
- 一貫性を保つためのオブジェクトの集合と、その入口となるルート。
- 例：`Order` が `OrderLine` を含む集約。

### 6. **ドメインサービス（Domain Service）**
- エンティティや値オブジェクトに属さない、ビジネスロジックを表現するサービス。
- 例：`PaymentProcessingService`

### 7. **リポジトリ（Repository）**
- 集約の永続化と再構築を担当するインターフェース。
- 例：`OrderRepository`, `CustomerRepository`

### 8. **ファクトリ（Factory）**
- 複雑なオブジェクトの生成を担当するコンポーネント。
- 例：`OrderFactory`

### 9. **バウンデッドコンテキスト（Bounded Context）**
- モデルが有効に機能する境界。コンテキストごとにユビキタス言語やモデルが異なる。
- 例：`Sales`, `Inventory`, `Billing` などのコンテキスト。

### 10. **コンテキストマップ（Context Map）**
- バウンデッドコンテキスト間の関係を示す図や記述。
- 例：`Customer` は `CRM` コンテキストでは詳細情報を持ち、`Order` コンテキストでは参照のみ。

### 11. **ドメインイベント（Domain Event）**
- ドメイン内で発生した意味のある出来事。
- 例：`OrderPlaced`, `PaymentConfirmed`

## 12.メモ
 - 特記事項など
```

### Step.2.2. サービスの候補の抽出

リストアップしたドメインやエンティティをマイクロサービスの候補として抽出します。
GitHub CopilotのCoding Agentを使っている場合は、step 2.1.でのPull Requestに追加でコメントしてもいいです。
GitHub Copilot Agent Modeを使っている場合は、同じチャットに追加してください。

```text
このユースケースにおいて、リストアップされた、全ての業務ドメインを深くかつ慎重に分析・解析をして、マイクロサービスとして実装するためのサービスの候補をリストアップしてください。{サービス候補一覧}のフォーマットに従ってください。

## 参考ドキュメント
  - docs/usecase/{ユースケースID}/usecase-description.md
  - docs/usecase/{ユースケースID}/domain-analytics.md

# 作成ファイル
  - docs/usecase/{ユースケースID}/service-list.md

# タスク
- 各ユースケースまたはユースケース群を、**単一責任の原則（SRP）**に基づいてサービス候補に分割します。
- サービス候補は、独立してデプロイ可能で、他サービスと疎結合であることが理想です。
- 全てのマイクロサービスをコンテキストマップとして、mermaid記法で図式化してください。

# サービス候補一覧

### {サービス候補ID}: {サービス候補名}

**ステータス**: 候補/承認/設計中/実装中/保留/統合検討/却下/廃止予定  
**BC**: {境界づけられたコンテキスト} / **サブドメイン**: コア/支援/汎用  
**対応UC**: {UC-ID, UC-ID,...}  
**一次責務（SRP）**:  
- {責務1}
- {責務2}

**非責務（明示）**: {例: 決済代行は担当しない}

#### ドメインモデル
- **アグリゲート/エンティティ**: {例: Order, OrderLine}
- **発行イベント**: {例: OrderPlaced, OrderCancelled}
- **購読イベント**: {例: PaymentCaptured}
- **不変条件/制約**: {例: 合計金額 ≥ 0}

#### データ所有・ストレージ
- **所有データ境界**: {箇条書き}
- **データ分類/機密度**: {公開/社内/機微/機密、APPI 対応?}
- **読み書き特性**: {例: R:W=4:1, 時系列追記型}
- **ストレージ選択/理由**: {例: Postgres（トランザクション）}
- **保持/アーカイブ**: {例: 7年、PIIは36ヶ月で削除}
- **RPO/RTO**: {例: 5分/30分}

#### インターフェース/契約
- **同期API**: {主要エンドポイント}
- **非同期契約**: {トピック/スキーマ}
- **契約版管理/互換方針**: {後方/前方互換}
- **Idempotency/整合性**: {戦略}

#### サービス間インタラクション
- **下流依存**: {例: PaymentSvc, InventorySvc}
- **上流依存**: {例: ShippingSvc}
- **通信方式（理由）**: {同期/非同期/混在 + 理由}
- **コンテキストマップ関係**: {例: Conformist}

#### 非機能
- **SLO/SLI**: {例: 99.95%, p95 200ms}
- **スケール特性**: {例: 2k rps, 年末 5x}
- **耐障害性**: {リトライ/タイムアウト/CB}
- **可観測性**: {メトリクス/ログ/トレース}

#### セキュリティ/コンプライアンス
- **認証/認可**: {例: OIDC + RBAC}
- **データ保護**: {At-rest/ In-transit 暗号化}
- **監査/規制**: {APPI/PCI 等}

#### 実装/デプロイ/運用
- **技術スタック**: {言語/ランタイム}
- **デプロイ単位**: {K8s/Serverless 等}
- **リージョン/DR**: {例: APNE1 主, APNE2 DR}
- **リリース戦略**: {Blue/Green/Canary}
- **Runbook**: {URL}

#### 意思決定
- **ビジネス価値**: {定性的/定量的}
- **リスク/不確実性**: {列挙}
- **規模見積**: {人週/リードタイム}
- **優先度スコア（式/値）**: {例: 価値×2 + 緊急度 + 依存解消×1.5 = 8.5}
- **代替案 / Split-Merge**: {記述}

#### 決定ログ & 未決
- **重要な決定**: {ADR リンク}
- **仮説/前提**: {列挙}
- **未解決事項（オーナー/期日）**: {列挙}
- **次アクション**: {列挙}
```

ここまですとリスト化されているだけですので。図式化したいなと思ったらMermaidなどを使ってみてください。以下はあくまで「例」です。マイクロサービスにおいて、どんな図表が有効なのかも、Copilotに聞いてみるのがおススメです。

### Step.2.3. データモデル作成

データモデルの作成は大変便利です。ここまでの業務要件の流れから抽出することで、プロトタイプとして利用者が利用イメージが湧きやすくなり自分事として捉えやすくなります。また、既存のデータソースとの接続が難しい場合など、それに引きずられること無く、アプリケーションの開発に入っていけます。

```text
このユースケースで使用する、全てのエンティティを深くかつ慎重に分析・解析をして、リストアップしてください。全てのエンティティを対象にしてデータモデル図をmermaid記法で図式化してください。

## 参考ドキュメント
  - docs/usecase/{ユースケースID}/usecase-description.md
  - docs/usecase/{ユースケースID}/domain-analytics.md
  - docs/usecase/{ユースケースID}/service-list.md

# 作成ファイル
  - docs/usecase/{ユースケースID}/data-model.md

# タスク
- 各サービスが独自のデータストアを持つように設計し、データの所有権を明確にします。
- 整合性は最終的整合性（Eventual Consistency）を前提に、イベントソーシングやCQRSなどのパターンを検討します。
- このユースケースで使用する、全てのエンティティの日本語のサンプルデータをjson形式で、エンティティ毎に別のデータとして10件ずつ作成をして表示してください。
  - 作成ファイル
    - data/{ユースケースID}-sample-data.json
```

### Step.2.4. 画面遷移図の作成

画面の作成に入ります。

```text
# 役割
あなたは、世界最高峰のソフトウェアエンジニアであり、同時に卓越したUX/UIデザイナーです。ユーザー中心設計（UCD）と最新のWeb技術（React, TypeScript, Tailwind CSS, Next.jsなど）に精通し、ビジネス価値とユーザー体験を両立させるWebアプリケーションを設計・実装します。アクセシビリティ、レスポンシブデザイン、パフォーマンス最適化、そして美的感覚に優れたUIを追求します。

## 行動指針：

- ユーザーの目的と文脈を深く理解し、最適なUX/UIを提案する
- コードは読みやすく、再利用性が高く、最新のベストプラクティスに準拠する
- デザインは直感的で、視覚的にも洗練されていること
- アクセシビリティ（WCAG）と国際化（i18n）を常に考慮する
- フィードバックを迅速に反映し、継続的に改善する

# 目的
このユースケースにおいて、ユーザーが利用する画面の一覧と画面遷移図を、深くかつ慎重に分析・解析をして、作成してください。

## 参考ドキュメント
  - docs/usecase/{ユースケースID}/usecase-description.md
  - docs/usecase/{ユースケースID}/service-list.md
  - docs/usecase/{ユースケースID}/data-model.md

# 作成ファイル
  - docs/usecase/{ユースケースID}/screen-list.md

## 出力形式

### 1. 画面一覧（Screen List）
以下の形式で画面をリストアップしてください。。次の情報を含めてください：
- screen_id: 画面ごとの一意のID
- screen_name: 画面名
- description: 画面の簡単な説明
- function_type: 主要機能（例：入力フォーム、承認画面、完了画面など）

### 2. 画面遷移図（Screen Transition Diagram）
画面遷移図は、テキストベースで画面IDまたは画面名をノードとして表現し、矢印（->）で遷移関係を記述してください。
#### 例：
[申請入力画面] -> [確認画面] -> [完了画面]
                       ↓
                [差し戻し画面]
または上記と同様のテキスト記述で明確にしてください。

追加で、画面遷移図はMermaid記法でも図式化してください。

### 3. エラーハンドリング
画面の特定や遷移が曖昧または資料から判断できない場合は、その旨を備考または注意事項として明記してください。
```

### Step.2.5. マッピング表の作成

このドキュメントを最終的に作りたかったのです!
画面とサービスとデータ。それぞれに識別のためのIDを付与して、今後、個々に仕様書として作成するドキュメントを紐づけます。

このマッピング表だけは、見直し改善Promptを実施しても良いかと思います。

[見直し改善Prompt](/高度なテクニック/README.md#4-promptを自己改善してもらう)

```text
このユースケースを、マイクロサービスアーキテクチャで構築するアプリケーションの、
画面 → **画面内機能 → 画面内処理 or API呼び出し → APIが管理するデータ
のマッピングを、深くかつ慎重に分析・解析をして、わかりやすい表形式で作成してください。
マイクロサービスアーキテクチャの原則を必ず守って設計を行ってください。

## 要件：

- 各画面ごとに、以下を整理すること
  - 画面ID
  - 画面名
  - 画面内の主要な機能（例：検索、登録、削除など）
  - その機能が「画面内処理」か「API呼び出し」かを明示
  - API呼び出しの場合は、API ID、API名、エンドポイント、HTTPメソッド、主要パラメータを記載
  - APIが管理するデータ（SoT）を明記
- 最後に、APIサービスと管理データの責務マッピング表も追加してください

さらに、可能であれば以下も含めてください：

- 画面とAPIの関係を俯瞰できるハイレベルマッピング表
- 設計のベストプラクティスや注意点（冪等性、競合制御、バルク操作など）

## 参考ドキュメント
  - docs/usecase/{ユースケースID}/usecase-description.md
  - docs/usecase/{ユースケースID}/service-list.md
  - docs/usecase/{ユースケースID}/data-model.md
  - docs/usecase/{ユースケースID}/screen-list.md

# 作成ファイル
  - docs/usecase/{ユースケースID}/service-mapping.md
```

作業手順の中で**機能やAPI**の概要を作成している点をお忘れなく。



## Step.3. 生成AIに最適化した各コンポーネントプロンプトの作成

> [!NOTE]
> これでもある程度は動きますが。もっとPromptとして最適化できると思います...

Step 3. で作成したユースケースの情報をもとに、生成AIに最適化したプロンプトを作成します。

### Step.3.1. 画面の作成

画面定義書は、既存のドキュメントを強く意識している「人」が理解しやすいであろう構造化情報として作成されています。


```text
# 役割
あなたは、世界最高峰のソフトウェアエンジニアであり、同時に卓越したUX/UIデザイナーです。ユーザー中心設計（UCD）と最新のWeb技術（React, TypeScript, Tailwind CSS, Next.jsなど）に精通し、ビジネス価値とユーザー体験を両立させるWebアプリケーションを設計・実装します。アクセシビリティ、レスポンシブデザイン、パフォーマンス最適化、そして美的感覚に優れたUIを追求します。

## 行動指針：

- ユーザーの目的と文脈を深く理解し、最適なUX/UIを提案する
- コードは読みやすく、再利用性が高く、最新のベストプラクティスに準拠する
- デザインは直感的で、視覚的にも洗練されていること
- アクセシビリティ（WCAG）と国際化（i18n）を常に考慮する
- フィードバックを迅速に反映し、継続的に改善する

# 目的
ソフトウェアでの実装のための画面の指示書を作成します。

# タスク
- 作成の対象は、全ての画面です。
- 作成する内容は、{指示書のガイドライン}をチェックリストとしてだけ**必ず**遵守して、深く分析・解釈してください。
- 先に作成した{日本語のサンプルデータ}の全てのデータを、データとして必ず追記してください。データが入っている事で、画面の作成後に、即座に利用することができるようにしてください。

## 参考ドキュメント
  - docs/usecase/{ユースケースID}/usecase-description.md
  - docs/usecase/{ユースケースID}/service-list.md
  - docs/usecase/{ユースケースID}/data-model.md
  - docs/usecase/{ユースケースID}/screen-list.md
  - docs/usecase/{ユースケースID}/service-mapping.md
  - data/{ユースケースID}-sample-data.json

# 作成ファイル
  - docs/usecase/{ユースケースID}/{画面-ID}-{画面名}-description.md
    - {画面-ID}は、各画面のIDを設定する
    - {画面名}は、各画面の名称を設定する

# 指示書のガイドライン

## 1. 全体評価

* プロンプトの目的とゴールの明確性を評価する。
* 受け入れ基準がテスト可能であることを示す。
* 機能追加の段階性（基礎 → 拡張 → 制約）を分析する。
* 曖昧さを取り除き、非機能要件・公平性・UXを補強する。

## 2. 仕様の厳密化

### コア機能

* **入力**：ユーザー単語リスト、任意のグリッドサイズ（デフォルト12×12、範囲6～20）。
* **配置**：8方向（N, NE, E, SE, S, SW, W, NW）、前後両向き。配置失敗時は一定回数リトライ。未使用セルはA–Zランダム。
* **検出**：マウス（クリック→ドラッグ→離す）、タッチ（長押し→スワイプ→離す）。直線一致で「発見」状態。
* **完了**：全語発見でタイマー停止、「新規パズル作成」ボタンを提示。

### タイマー & リーダーボード

* **開始**：生成直後に自動スタート。
* **停止**：最後の語発見時に停止。
* **フォーマット**：`MM:SS.mmm`（ms精度、表示は四捨五入）。
* **記録項目**：名前、時間、語数、サイズ。
* **ソート**：昇降順切替可能（時間／語数／名前）。同率時は**時間→語数→名前**でタイブレーク、安定ソート必須。
* **公平性**：サイズ×語数ごとにランキングを分離。

### 入力制約 & エラー

* **単語長 ≤ min(行, 列)**。違反時は「語はサイズ以下にしてください」と即時エラー。
* **文字種**：A–Z（大文字小文字非区別、空白/ハイフン除去）。
* **重複語**：一意化または警告のいずれかを仕様化。
* **最大語数**：例 5–20、超過や配置不能時は「語数を減らすかサイズを増やしてください」。

### データモデル & アルゴリズム

* **モデル**：`Grid`, `Word{text, path}`, `Score{name, timeMs, wordCount, gridSize}`。
* **配置**：ランダム起点＋方向、失敗時リトライ（上限=面積×2）。
* **乱数**：毎回変化（将来拡張でシード固定可）。
* **性能目安**：12×12で10語 → 100ms以内に生成。

### UX / A11y

* **キーボード操作**：矢印移動＋Enterで選択、Escで解除。
* **色覚対応**：色＋下線／太字併用。
* **スクリーンリーダー**：`aria-live`で進捗を読み上げ。
* **フォーカス管理**：タブ順序保証。

### セキュリティ & プライバシー

* 名前入力はサニタイズ、最大長24文字、制御文字禁止。
* 保存範囲はローカルのみ。共有や送信は行わない。

### 非機能要件

* 反応速度：検出レスポンス16ms以内。
* 永続化：localStorageに100件まで履歴保存。
* オフライン：PWA拡張可能。

### アンチ要件（除外範囲）

* ヒント機能、マルチプレイ、サーバ同期、厳格チート検出は含めない。

## 3. 曖昧さと解決

* 「斜め」＝NE／NW／SE／SW の4方向と明記。
* 「ドラッグ」＝連続セル追従操作と定義。
* タイマーは一時停止なし。
* 同率スコアは必ず単一順位を決定。

## 4. 受け入れ基準例（Gherkin風）

* **語長境界**：10×10で長さ10 → 成功。長さ11 → エラー表示。
* **操作**：連続セルドラッグで一致 → 発見状態＋バンクにチェック。
* **タイマー**：生成直後に`00:00.000`から加算開始、全語発見で停止。
* **ランキング**：時間昇順、同率は語数→名前順。

## 5. リスクとトレードオフ

* 語数過多×小サイズ → 自動拡大提案。
* 色のみ強調はNG → 装飾併用で補正。
* ローカル保存はチート耐性低 → 許容範囲と明示。

## 6. 拡張余地

* 難易度プリセット、カテゴリ別語リスト、辞書検証、シード固定、PWA対応、共有ランキングAPI。

## 7. 最終チェックリスト

* ゴール／完了条件／操作が一読で明確か？
* 8方向＋逆方向が定義されているか？
* 境界値とエラーメッセージが明文化されているか？
* タイマー仕様（開始・停止・丸め）が厳密か？
* リーダーボードが公平で、ソート＋同率処理が定義されているか？
* A11y・非機能要件が網羅されているか？
* スコープ外が宣言されているか？
```

参考:
https://docs.github.com/en/copilot/tutorials/easy-apps-with-spark

### Step.3.2. マイクロサービスの作成

サービスの候補から、1つを選んで、マイクロサービス定義書に準拠したドキュメントを作成します。

Prompt:

```text
ユースケースの全てのサービスを対象として、{マイクロサービス定義書}に準拠したマイクロサービスのドキュメントを作成してください。

## 参考ドキュメント
  - docs/usecase/{ユースケースID}/usecase-description.md
  - docs/usecase/{ユースケースID}/service-list.md
  - docs/usecase/{ユースケースID}/data-model.md
  - docs/usecase/{ユースケースID}/service-mapping.md
  - data/{ユースケースID}-sample-data.json


# 作成ファイル
  - docs/usecase/{ユースケースID}/{サービスID}-{サービス名}-description.md
    - {サービスID}は、各サービスのIDを設定する
    - {サービス名}は、各サービスの名称を設定する

## マイクロサービス定義書

### 1. **サービスメタ情報**
- **サービス名／短縮名**：例）Template Service（TPL）  
- **概要（One-liner）**：何を「いつ・誰に・なぜ」提供するか。  
- **責務（Do）／非責務（Don’t）**：境界の明示。承認ルーティング**実行**は非責務 等。  
- **利害関係者・主要ペルソナ**（任意）：管理者、部門管理者、申請者、監査。

### 2. **ビジネス能力・コンテキスト**
- **対象ドメインとユースケースの対応表**：FR-002-01 下位要件とのトレーサビリティ。  
- **ライフサイクル**：ドラフト→レビュー→公開→廃止（状態と遷移イベント）。

### 3. **公開インターフェース（同期）**
- **API スタイル**：REST（JSON/UTF‑8）（※GraphQL 等の場合は理由）。  
- **リソース一覧（概要）**：`/templates`、`/types`、`/fields`、`/diff`、`/preview` …（**動詞ではなく名詞**で統一）。  
- **操作粒度**：作成／取得／検索（フィルタ・ソート・ページング規約）／公開／廃止／差分取得／プレビュー。  
- **冪等性**：`Idempotency-Key` の扱い、重複作成の基準。  
- **エラー語彙（概要）**：`TPL-VAL-001 必須欠落`、`TPL-STATE-001 状態不正` などの**コード体系と責務境界**。  
> ※後でコード生成するため、ここには**OpenAPI の骨子**（パス・ステータス・代表スキーマ名）だけを置く。

### 4. **公開インターフェース（非同期）**
- **ドメインイベント（発行）**：`TEMPLATE.PUBLISHED`、`TEMPLATE.RETIRED` など。  
  - 目的、発火条件、**最小ペイロード項目**（識別子、版、適用開始、破壊的変更フラグ 等）。  
- **サブスクライブ（受信）**：MDM 更新、承認ルール変更、インボイス検証結果 等。  
- **配信保証**：少なくとも 1 回／順序性／再送ポリシー（概念レベル）。  
> ※後でコード生成するため、ここには**AsyncAPI の骨子**（チャンネル名・メッセージ名・キー属性）だけを置く。

### 5. **データ所有・モデル（概念）**
- **主エンティティと所有者**：Template（本サービス所有）、RequestType（同）、AttachmentPolicy（同） 等。  
- **整合性・一意性ルール**：同一 `typeId` で同時点に有効な版は1つ、破壊的変更は新規版 等。  
- **データ分類／個人情報**：PII/非PII、電帳法検索キーの取り扱い。  
- **マルチテナンシ／スコープ**：全社／部門／ロール／属性（可視性の粒度）。

### 6. **セキュリティ・権限**
- **認証**：OIDC/SSO（MFA 前提）。  
- **認可**：RBAC/ABAC（属性例：部門 ID、役職、委任期間）。  
- **暗号化**：転送中 TLS、保存時 KMS、添付はオブジェクトストレージのサーバサイド暗号化。  
- **監査**：操作（作成／編集／公開／廃止／ロールバック）の**不可改ざん記録**（何を・誰が・いつ・どこから）。

### 7. **外部依存・統合**
- **依存先と契約**：  
  - MDM/HR（組織・職位・権限・委任）  
  - 承認エンジン（RuleSet 参照のみ）  
  - 電帳法対応ストレージ／タイムスタンプ  
  - インボイス検証 API  
  - ERP/会計/契約台帳/DWH  
- **フォールバック戦略**：外部検証障害時は暫定許可→**後続検証キュー**、時間切れ時のポリシー。

### 8. **状態遷移・ビジネスルール**
- **状態機械（概念図）**：Draft → InReview → Published → Retired（RollBack 可否）。  
- **条件分岐の原則**：金額・カテゴリ・海外判定等に基づく動的表示／必須化の**安全側フォールバック**。  
- **公開可否ゲート**：電帳法検索キーが欠落するテンプレは公開不可 等。

### 9. **非機能・SLO（概念）**
- **可用性／パフォーマンス目安**：例）p50/p95 レイテンシ、同時編集想定、イベント伝播遅延上限。  
- **スケーラビリティ**：読み主体（一覧・プレビュー）最適化、書き（公開）時の直列化。  
- **運用監視**：メトリクス（差戻し率、滞留時間、公開後エラー率）、トレース、構成変更監視。  

### 10. **バージョニング／互換性**
- **API 版付け**：`/api/v1/...` の原則、後方互換の維持と**廃止告知期間**。  
- **テンプレ版と適用範囲**：新規起票には最新版、既存案件は旧版維持／ドラフトの自動マイグレーション方針（案内のみ、強制なし）。  
- **イベント版付け**：メッセージの `schemaVersion` と互換規約。

### 11. **エラー・レート制御・再試行**
- **エラー体系（概要）**：`TPL-VAL-xxx`（検証）、`TPL-STATE-xxx`（状態）、`TPL-API-xxx`（外部障害）など**命名規約**。  
- **レート制限**：管理操作（公開・廃止）は保守的、読み取りは緩め。  
- **再試行ポリシー**：クライアント／サーバの責務分界、**冪等性キー**利用時の再送許容。

### 12. **設定・フラグ**
- **機能フラグ**：ローカライズ有効化、OCR 有効化、破壊的変更ガード。  
- **構成キー**：外部 API タイムアウト、最大添付サイズ、OCR リトライ回数（値はここでは**未記載**）。

### 13. **移行・初期データ（任意）**
- **初期テンプレの投入計画**、旧システムからの**読み替え原則**、識別子のマッピング方針。

### 14. **テスト指針（概念）**
- **契約テスト**（Provider/Consumer）、**状態遷移テスト**、**ローカライズの可用性テスト**、**監査改ざん検知テスト**。  
- **テストデータ原則**：サンプルテンプレと最小必須証憑。

### 15. **運用・リリース（概念）**
- **デプロイ戦略**：ローリング／カナリア（公開・廃止の**時間指定**に対応）。  
- **ロールバック**：API とデータの整合を保つための**版単位**ロールバック手順（概念）。  
- **通知・チェンジマネジメント**：リリースノート、影響分析、対象ユーザへの配布ポリシー。

### 16. **リスク・オープン課題**
- 例：外部検証 API の SLA 未定義、MDM の属性欠落、部門差分の継承衝突 等。

## 17. **画面・操作・API・イベント マッピング**
- **目的**：UI（画面）とマイクロサービスの責務を明確化し、疎結合な設計を担保する。  
- **マッピング表**：
- **原則**：  
  - 1画面＝1主要サービス（UIロジックは集約しない）  
  - 複数サービスを呼ぶ場合は**BFF（Backend for Frontend）**でオーケストレーション  
  - 画面IDはFRDやUI設計書とトレーサブルに  

### 付録 A（コード生成用の“骨子”を添付）
- **OpenAPI（スケルトン）**：パス・メソッド・代表スキーマ名のみ。  
- **AsyncAPI（スケルトン）**：チャンネル名・イベント名・キー属性のみ。  
- **JSON Schema（概念版）**：`Template`, `FieldDefinition`, `AttachmentPolicy` の最低限属性。  
- **用語集／語彙**：ラベル、状態、エラーコードの辞書。
```
